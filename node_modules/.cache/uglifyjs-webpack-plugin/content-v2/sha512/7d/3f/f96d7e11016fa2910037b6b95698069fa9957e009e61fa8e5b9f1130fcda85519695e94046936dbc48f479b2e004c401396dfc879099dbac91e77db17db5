{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{175:function(t,a,r){\"use strict\";r.r(a);var e=r(0),s=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,r=t._self._c||a;return r(\"div\",{staticClass:\"content\"},[r(\"h1\",{attrs:{id:\"函数防抖-函数节流\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#函数防抖-函数节流\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 函数防抖&函数节流\")]),t._v(\" \"),r(\"p\",[t._v(\"函数节流和函数防抖是JS比较重要的概念，应用好了可以提高很大的性能，在面试中也是很高频的一个考点。下面一起来看看这两中方法是如何使用的：\")]),t._v(\" \"),r(\"h2\",{attrs:{id:\"函数防抖\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#函数防抖\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 函数防抖:\")]),t._v(\" \"),r(\"h3\",{attrs:{id:\"概念：\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#概念：\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 概念：\")]),t._v(\" \"),r(\"p\",[t._v(\"在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。\")]),t._v(\" \"),r(\"h3\",{attrs:{id:\"理解概念：\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#理解概念：\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 理解概念：\")]),t._v(\" \"),r(\"h3\",{attrs:{id:\"应用场景：\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#应用场景：\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 应用场景：\")]),t._v(\" \"),r(\"h2\",{attrs:{id:\"函数节流\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#函数节流\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 函数节流\")]),t._v(\" \"),r(\"p\",[t._v(\"函数防抖和函数节流主要解决的问题是：防止函数”短时间“的重复执行。\")]),t._v(\" \"),r(\"p\",[t._v(\"它们的本质上是：在时间轴上控制函数的次数。\")])])}],!1,null,null,null);s.options.__file=\"函数防抖和函数节流.md\";a.default=s.exports}}]);","extractedComments":[]}