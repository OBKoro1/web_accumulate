{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{173:function(e,t,r){\"use strict\";r.r(t);var n=r(0),a=Object(n.a)({},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r(\"div\",{staticClass:\"content\"},[e._m(0),e._v(\" \"),e._m(1),e._v(\" \"),r(\"p\",[e._v(\"给定非空字符串s，您最多可以删除一个字符。判断是否可以成为回文。\")]),e._v(\" \"),r(\"p\",[e._v(\"该字符串仅包含小写字符a-z,字符串的最大长度为50000。\")]),e._v(\" \"),e._m(2),e._v(\" \"),r(\"p\",[e._v('Given s = \"aba\" return true')]),e._v(\" \"),r(\"p\",[e._v('Given s = \"abca\" return true // delete c')]),e._v(\" \"),e._m(3),e._v(\" \"),e._m(4),e._v(\" \"),e._m(5),e._v(\" \"),e._m(6),e._v(\" \"),r(\"h3\",{attrs:{id:\"代码地址\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#代码地址\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" \"),r(\"a\",{attrs:{href:\"https://github.com/OBKoro1/Brush_algorithm/blob/9bc3c386129f03f93120265c88d4d6250bdcc416/codeSource/Palindrome.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"代码地址\"),r(\"OutboundLink\")],1)]),e._v(\" \"),r(\"h3\",{attrs:{id:\"github-算法仓库地址\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#github-算法仓库地址\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" \"),r(\"a\",{attrs:{href:\"https://github.com/OBKoro1/Brush_algorithm\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"github 算法仓库地址\"),r(\"OutboundLink\")],1)]),e._v(\" \"),r(\"p\",[e._v(\"2018.8.12\")])])},[function(){var e=this.$createElement,t=this._self._c||e;return t(\"h2\",{attrs:{id:\"删除一个字母的回文\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#删除一个字母的回文\",\"aria-hidden\":\"true\"}},[this._v(\"#\")]),this._v(\" 删除一个字母的回文\")])},function(){var e=this.$createElement,t=this._self._c||e;return t(\"h3\",{attrs:{id:\"描述\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#描述\",\"aria-hidden\":\"true\"}},[this._v(\"#\")]),this._v(\" 描述\")])},function(){var e=this.$createElement,t=this._self._c||e;return t(\"h3\",{attrs:{id:\"样例：\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#样例：\",\"aria-hidden\":\"true\"}},[this._v(\"#\")]),this._v(\" 样例：\")])},function(){var e=this.$createElement,t=this._self._c||e;return t(\"h3\",{attrs:{id:\"题目分析：\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#题目分析：\",\"aria-hidden\":\"true\"}},[this._v(\"#\")]),this._v(\" 题目分析：\")])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r(\"ul\",[r(\"li\",[r(\"p\",[e._v(\"如果单单是回文的话，就很简单了:\")]),e._v(\" \"),r(\"pre\",[r(\"code\",[e._v('  s === [...s].reverse().join(\"\"); // 翻转字符串与原字符相比\\n  // 实际上这里做了很多步操作，字符转数组 翻转数组 再转字符串，所以这里性能也不是很好\\n  // 如果对性能要求比较高的话，还是通过循环从两侧向中间逐一比较，会更好一点\\n')])])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"题目中还有一个要求：删除一个字符，也就是允许一个字符的不同。\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"下面我们的解法主体思路就是\"),r(\"strong\",[e._v(\"通过循环，从两侧向中间比较\")]),e._v(\"，然后解决当出现不同的情况，如何\"),r(\"strong\",[e._v(\"保证只允许出现一个不同\")]),e._v(\"。\")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t(\"h3\",{attrs:{id:\"code\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#code\",\"aria-hidden\":\"true\"}},[this._v(\"#\")]),this._v(\" code:\")])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r(\"ol\",[r(\"li\",[r(\"p\",[e._v(\"出现一处不同 将值传入一个新函数，再进行判断字符串：\")]),e._v(\" \"),r(\"pre\",[r(\"code\",[e._v(\" const validPalindrome = s => {\\n     let left = 0;\\n     let right = s.length - 1;\\n     while (left < right) {\\n         if (s[left] !== s[right]) {\\n             // 左右两边字符都要尝试一下 一边返回true即可\\n             return isSubPalindrom(s, left + 1, right) || isSubPalindrom(s, left, right - 1); \\n         }\\n         left++;\\n         right--;\\n     }\\n     return true; // 循环结束返回true\\n }\\n const isSubPalindrom = (s, left, right) => {\\n     while (left < right) {\\n         if (s[left] !== s[right]) {\\n             return false; // 再有不同之处 返回false\\n         }\\n         left++;\\n         right--;\\n     }\\n     return true; // 循环结束一直相等返回true\\n     // 并且left不小于right 直接返回right，说明不同之处只有一个\\n }\\n console.log('回文验证:', validPalindrome('abaacaaa'), validPalindrome('ab'), validPalindrome('abc'), validPalindrome('aabsjdbaa'))\\n\")])]),e._v(\" \"),r(\"p\",[e._v(\"这个写好之后，我在想能不能通过递归的形式来解决，\"),r(\"strong\",[e._v(\"为什么要创建第二个函数\")]),e._v(\"？\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"递归解法：\")]),e._v(\" \"),r(\"pre\",[r(\"code\",[e._v(\" const validPalindrome = (s, left = 0, right = s.length - 1, type = 'first') => {\\n     if (type === 'first') {\\n         // 第一次进入允许出现一次不同\\n         while (left < right) {\\n             if (s[left] !== s[right]) {\\n                 return validPalindrome(s, left + 1, right, 'second') || validPalindrome(s, left, right - 1, 'second'); // 左右两边都尝试一下 一边返回true即可\\n             }\\n             left++;\\n             right--;\\n         }\\n         return true; // 循环结束返回true\\n     } else {\\n         // 第二次 再有不同之处 返回false\\n         while (left < right) {\\n             if (s[left] !== s[right]) {\\n                 return false; \\n             }\\n             left++;\\n             right--;\\n         }\\n         return true; // 循环结束一直相等返回true\\n         // 并且left不小于right 直接返回right，说明不同之处只有一个\\n     }\\n }\\n console.log('回文验证:', validPalindrome('abaacaaa'), validPalindrome('ab'), validPalindrome('abc'), validPalindrome('aabsjdbaa'))\\n\")])]),e._v(\" \"),r(\"p\",[e._v(\"相对于上个解法这里就是多设置了一个变量，然后将两方区分开来，但是这样递归我还是觉得太傻了，所以在想你\"),r(\"strong\",[e._v(\"能不能通过设置变量来处理\")]),e._v(\"？出现两次不同即失败。\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"设置一个变量允许一次不同\")]),e._v(\" \"),r(\"pre\",[r(\"code\",[e._v(\" const validPalindrome = s => {\\n     let removed = false;\\n     for (let [i, j] = [0, s.length - 1]; i < j; i++ , j--) {\\n         // 从两侧向中间递减 i- j-1 减到最后 i>j i=j 退出循环\\n         if (s[i] !== s[j]) { // 如果两侧不相同\\n             if (removed) { // 只允许一次不同\\n                 return false;\\n             }\\n             if (s[i] === s[j - 1]) {\\n                 // 转数组删除一个不同元素 下次直接return\\n                 // s = [...s].splice(j, 1);\\n                 // s = s.join(''); // 处理过的字符串\\n                 j--;\\n                 removed = true;\\n             } else if (s[i + 1] === s[j]) {\\n                 // s = [...s].splice(i, 1);\\n                 // s = s.join(''); // 处理过的字符串\\n                 i++;\\n                 removed = true;\\n             } else {\\n                 // 上面两个else 右边-1 或左边+1相不相等 如果两边也不相等即false\\n                 return false;\\n             }\\n         }\\n     }\\n     return true;\\n }\\n console.log('回文验证:', validPalindrome('abaacaaa'), validPalindrome('ab'), validPalindrome('abc'), validPalindrome('aabsjdbaa'))\\n\")])])])])}],!1,null,null,null);a.options.__file=\"回文.md\";t.default=a.exports}}]);","extractedComments":[]}