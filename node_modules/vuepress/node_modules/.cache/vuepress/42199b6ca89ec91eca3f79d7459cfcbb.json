{"remainingRequest":"/Users/koro/work/web_my/web_accumulate/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/koro/work/web_my/web_accumulate/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/koro/work/web_my/web_accumulate/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/koro/work/web_my/web_accumulate/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/koro/work/web_my/web_accumulate/docs/accumulate/ES6/js调用栈机制与ES6尾调用优化介绍.md?vue&type=template&id=c2c4835a&","dependencies":[{"path":"/Users/koro/work/web_my/web_accumulate/docs/accumulate/ES6/js调用栈机制与ES6尾调用优化介绍.md","mtime":1564740892015},{"path":"/Users/koro/work/web_my/web_accumulate/node_modules/cache-loader/dist/cjs.js","mtime":1557296864520},{"path":"/Users/koro/work/web_my/web_accumulate/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1557296867191},{"path":"/Users/koro/work/web_my/web_accumulate/node_modules/cache-loader/dist/cjs.js","mtime":1557296864520},{"path":"/Users/koro/work/web_my/web_accumulate/node_modules/vue-loader/lib/index.js","mtime":1557296867190},{"path":"/Users/koro/work/web_my/web_accumulate/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1557296867284}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<h2 id=\\\"js-调用栈机制与es6尾调用优化介绍\\\"><a href=\\\"#js-调用栈机制与es6尾调用优化介绍\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> js 调用栈机制与ES6尾调用优化介绍</h2> <p>调用栈的英文名叫做Call Stack，大家或多或少是有听过的，但是对于js调用栈的工作方式以及如何在工作中利用这一特性，大部分人可能没有进行过更深入的研究，这块内容可以说对我们前端来说就是所谓的基础知识，咋一看好像用处并没有很大，但掌握好这个知识点，就可以让我们在以后可以走的更远，走的更快！</p> \"),_vm._ssrNode(\"<blockquote>\",\"</blockquote>\",[_vm._ssrNode(\"<p>\",\"</p>\",[_vm._ssrNode(\"<a href=\\\"http://obkoro1.com/\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"博客\"),_c('OutboundLink')],2),_vm._ssrNode(\"、\"),_vm._ssrNode(\"<a href=\\\"http://obkoro1.com/web_accumulate/accumulate/\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"前端积累文档\"),_c('OutboundLink')],2),_vm._ssrNode(\"、\"),_vm._ssrNode(\"<a href=\\\"https://github.com/OBKoro1/articleImg_src/blob/master/juejin/1631b6f52f7e7015.jpeg?raw=true\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"公众号\"),_c('OutboundLink')],2),_vm._ssrNode(\"、\"),_vm._ssrNode(\"<a href=\\\"https://github.com/OBKoro1\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"GitHub\"),_c('OutboundLink')],2)],2)]),_vm._ssrNode(\" <hr> <h3 id=\\\"目录\\\"><a href=\\\"#目录\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 目录</h3> <ol><li>数据结构：栈</li> <li>调用栈是什么？用来做什么？</li> <li>调用栈的运行机制</li> <li>调用栈优化内存</li> <li>调用栈debug大法</li></ol> <h3 id=\\\"数据结构：栈\\\"><a href=\\\"#数据结构：栈\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 数据结构：栈</h3> <p>栈是一种遵从<strong>后进先出(<code>LIFO</code>)原则的有序集合</strong>，新元素都靠近栈顶，旧元素都接近栈底。</p> <p>生活中的栗子，帮助一下理解：</p> <p>餐厅里面堆放的盘子(栈)，一开始放的都在下面(先进)，后面放的都在上面(后进)，洗盘子的时候先从上面开始洗(先出)。</p> <h3 id=\\\"调用栈是什么？用来做什么？\\\"><a href=\\\"#调用栈是什么？用来做什么？\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 调用栈是什么？用来做什么？</h3> <ol><li><strong>调用栈是一种栈结构的数据，它是由调用侦组成的</strong>。</li> <li><strong>调用栈记录了函数的执行顺序和函数内部变量等信息</strong>。</li></ol> <h4 id=\\\"调用栈的运行机制\\\"><a href=\\\"#调用栈的运行机制\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 调用栈的运行机制</h4> <p><strong>机制</strong>：</p> <p>程序运行到一个函数，它就会将其添加到调用栈中，当从这个函数返回的时候，就会将这个函数从调用栈中删掉。</p> <p>看一下例子帮助理解：</p> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token comment\\\">// 调用栈中的执行步骤用数字表示</span>\\n<span class=\\\"token function\\\">printSquare</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">5</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// 1 添加</span>\\n<span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">printSquare</span><span class=\\\"token punctuation\\\">(</span>x<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">var</span> s <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">multiply</span><span class=\\\"token punctuation\\\">(</span>x<span class=\\\"token punctuation\\\">,</span> x<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// 2 添加 =&gt; 3 运行完成，内部没有再调用其他函数，删掉</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>s<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// 4 添加 =&gt; 5 删掉</span>\\n    <span class=\\\"token comment\\\">// 运行完成 删掉printSquare</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">multiply</span><span class=\\\"token punctuation\\\">(</span>x<span class=\\\"token punctuation\\\">,</span> y<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">return</span> x <span class=\\\"token operator\\\">*</span> y<span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br><span class=\\\"line-number\\\">9</span><br><span class=\\\"line-number\\\">10</span><br></div></div><p>调用栈中的执行步骤如下(删除multiply的步骤被省略了)：</p> <p><img src=\\\"https://github.com/OBKoro1/articleImg_src/blob/master/juejin/16acb4a439190d49?raw=true\\\" alt></p> <p><strong>调用侦</strong>：</p> <p>每个进入到调用栈中的函数，都会分配到一个单独的栈空间，称为“调用侦”。</p> <p>在调用栈中每个“调用侦”都对应一个函数，最上方的调用帧称为“当前帧”，调用栈是由所有的调用侦形成的。</p> <p>找到一张图片，调用侦：</p> <p><img src=\\\"https://github.com/OBKoro1/articleImg_src/blob/master/juejin/16ace8030a36c8dd?raw=true\\\" alt></p> <h3 id=\\\"调用栈优化内存\\\"><a href=\\\"#调用栈优化内存\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 调用栈优化内存</h3> <p><strong>调用栈的内存消耗</strong>：</p> <p>如上图，函数的变量等信息会被调用侦保存起来，所以<strong>调用侦中的变量不会被垃圾收集器回收</strong>。</p> <p>当函数嵌套的层级比较深了，调用栈中的调用侦比较多的时候，这些信息对内存消耗是非常大的。</p> <p>针对这种情况除了我们要尽量避免函数层级嵌套的比较深之外，ES6提供了“尾调用优化”来解决调用侦过多，引起的内存消耗过大的问题。</p> <p><strong>何谓尾调用</strong>：</p> <p>尾调用指的是：<strong>函数的最后一步是调用另一个函数</strong>。</p> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">f</span><span class=\\\"token punctuation\\\">(</span>x<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">return</span> <span class=\\\"token function\\\">g</span><span class=\\\"token punctuation\\\">(</span>x<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// 最后一步调用另一个函数并且使用return</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">f</span><span class=\\\"token punctuation\\\">(</span>x<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">g</span><span class=\\\"token punctuation\\\">(</span>x<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// 没有return 不算尾调用 因为不知道后面还有没有操作</span>\\n  <span class=\\\"token comment\\\">// return undefined; // 隐式的return</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br></div></div><p><strong>尾调用优化优化了什么？</strong></p> <p>尾调用用来<strong>删除外层无用的调用侦</strong>，只保留内层函数的调用侦，来节省浏览器的内存。</p> <p>下面这个例子调用栈中的调用侦一直只有一项，如果不使用尾调用的话会出现三个调用侦：</p> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token function\\\">a</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// 1 添加a到调用栈</span>\\n<span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">a</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">return</span> <span class=\\\"token function\\\">b</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// 在调用栈中删除a 添加b</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">b</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">return</span> <span class=\\\"token function\\\">c</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// 删除b 添加c</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br></div></div><p><strong>防止爆栈</strong>：</p> \"),_vm._ssrNode(\"<p>\",\"</p>\",[_vm._ssrNode(\"浏览器对\"),_vm._ssrNode(\"<a href=\\\"https://codeday.me/bug/20170824/62171.html\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"调用栈都有大小限制\"),_c('OutboundLink')],2),_vm._ssrNode(\"，在ES6之前递归比较深的话，很容易出现“爆栈”问题(stack overflow)。\")],2),_vm._ssrNode(\" <p>现在可以使用“尾调用优化”来写一个“尾递归”，只保存一个调用侦，来防止爆栈问题。</p> <p><strong>注意</strong>：</p> <ol><li>只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧。</li></ol> <blockquote><p>如果要使用外层函数的变量，可以通过参数的形式传到内层函数中</p></blockquote> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">a</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">var</span> aa <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">let</span> <span class=\\\"token function-variable function\\\">b</span> <span class=\\\"token operator\\\">=</span> val <span class=\\\"token operator\\\">=&gt;</span> aa <span class=\\\"token operator\\\">+</span> val <span class=\\\"token comment\\\">// 使用了外层函数的参数aa</span>\\n    <span class=\\\"token keyword\\\">return</span> <span class=\\\"token function\\\">b</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">2</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// 无法进行尾调用优化</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br></div></div><ol start=\\\"2\\\"><li>尾调用优化只在严格模式下开启，非严格模式是无效的。</li> <li>如果环境不支持“尾调用优化”，代码还可以正常运行，是无害的！</li></ol> <p><strong>更多</strong>：</p> \"),_vm._ssrNode(\"<p>\",\"</p>\",[_vm._ssrNode(\"关于尾递归以及更多尾调用优化的内容，推荐查阅\"),_vm._ssrNode(\"<a href=\\\"http://es6.ruanyifeng.com/#docs/function#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"ES6入门-阮一峰\"),_c('OutboundLink')],2)],2),_vm._ssrNode(\" <h3 id=\\\"调用栈debug大法\\\"><a href=\\\"#调用栈debug大法\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 调用栈debug大法</h3> <p><strong>查看调用栈有什么用</strong></p> <ol><li><p>查看函数的调用顺序是否跟预期一致，比如不同判断调用不同函数。</p></li> <li><p>快速定位问题/修改三方库的代码。</p> <p>当接手一个历史项目，或者引用第三方库出现问题的时候，可以先查看对应API的调用栈，找到其中涉及的关键函数，针对性的修复它。</p> <p>通过查看调用栈的形式，帮助我快速定位问题，修改三方库的源码。</p></li></ol> <p><strong>如何查看调用栈</strong></p> <ol><li>只查看调用栈：<code>console.trace</code></li></ol> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token function\\\">a</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span>\\n<span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">a</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token function\\\">b</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">b</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token function\\\">c</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">c</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">let</span> aa <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">;</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">trace</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br><span class=\\\"line-number\\\">9</span><br><span class=\\\"line-number\\\">10</span><br><span class=\\\"line-number\\\">11</span><br></div></div><p>如图所示,点击右侧还能查看代码位置：</p> <p><img src=\\\"https://github.com/OBKoro1/articleImg_src/blob/master/juejin/16ad3f508ab127a9?raw=true\\\" alt></p> <ol start=\\\"2\\\"><li><code>bugger</code>打断点形式，这也是我最喜欢的调试方式：</li></ol> <p><img src=\\\"https://github.com/OBKoro1/articleImg_src/blob/master/juejin/16ad3ff354f2dac3?raw=true\\\" alt></p> <h2 id=\\\"结语\\\"><a href=\\\"#结语\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 结语</h2> <p>本文主要讲了这几个方面的内容：</p> <ol><li>理解调用栈的运行机制，对代码背后的一些执行机制也可以更加了解，帮助我们在百尺竿头更进一步。</li> <li>我们应该在日常的code中，有意识的使用ES6的“尾调用优化”，来减少调用栈的长度，节省客户端内存。</li> <li>利用调用栈，对第三方库或者不熟悉的项目，可以更快速的定位问题，提高我们debug速度。</li></ol> \"),_vm._ssrNode(\"<p>\",\"</p>\",[_vm._ssrNode(\"最后：之前写过一篇关于\"),_vm._ssrNode(\"<a href=\\\"https://juejin.im/post/5b40581e5188251ac446c716\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"垃圾回收机制与内存泄露\"),_c('OutboundLink')],2),_vm._ssrNode(\"的文章，感兴趣的同学可以扩展一下。\")],2),_vm._ssrNode(\" <p>以上2019/5/19</p> <p>参考资料：</p> \"),_vm._ssrNode(\"<p>\",\"</p>\",[_vm._ssrNode(\"<a href=\\\"https://juejin.im/post/5b40581e5188251ac446c716\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"JS垃圾回收机制与常见内存泄露的解决方法\"),_c('OutboundLink')],2)]),_vm._ssrNode(\" \"),_vm._ssrNode(\"<p>\",\"</p>\",[_vm._ssrNode(\"<a href=\\\"http://es6.ruanyifeng.com/#docs/function#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"ES6入门-阮一峰\"),_c('OutboundLink')],2)]),_vm._ssrNode(\" \"),_vm._ssrNode(\"<p>\",\"</p>\",[_vm._ssrNode(\"<a href=\\\"https://juejin.im/post/5a05b4576fb9a04519690d42\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"JavaScript 如何工作：对引擎、运行时、调用堆栈的概述\"),_c('OutboundLink')],2)]),_vm._ssrNode(\" \"),_vm._ssrNode(\"<p>\",\"</p>\",[_vm._ssrNode(\"<a href=\\\"https://segmentfault.com/a/1190000010360316\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"浅析javascript调用栈\"),_c('OutboundLink')],2)]),_vm._ssrNode(\" \"),_vm._ssrNode(\"<h3 id=\\\"点个star支持我一下\\\">\",\"</h3>\",[_vm._ssrNode(\"<a href=\\\"#点个star支持我一下\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 点个\"),_vm._ssrNode(\"<a href=\\\"https://github.com/OBKoro1/web_accumulate\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"Star\"),_c('OutboundLink')],2),_vm._ssrNode(\"支持我一下~\")],2),_vm._ssrNode(\" \"),_c('comment-comment')],2)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}