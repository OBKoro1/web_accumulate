{"remainingRequest":"/Users/koro/work/web_my/web_accumulate/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/koro/work/web_my/web_accumulate/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/koro/work/web_my/web_accumulate/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/koro/work/web_my/web_accumulate/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/koro/work/web_my/web_accumulate/docs/accumulate/JS/prototype.md?vue&type=template&id=f10d4c62&","dependencies":[{"path":"/Users/koro/work/web_my/web_accumulate/docs/accumulate/JS/prototype.md","mtime":1636107879468},{"path":"/Users/koro/work/web_my/web_accumulate/node_modules/cache-loader/dist/cjs.js","mtime":1557296864520},{"path":"/Users/koro/work/web_my/web_accumulate/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1557296867191},{"path":"/Users/koro/work/web_my/web_accumulate/node_modules/cache-loader/dist/cjs.js","mtime":1557296864520},{"path":"/Users/koro/work/web_my/web_accumulate/node_modules/vue-loader/lib/index.js","mtime":1557296867190},{"path":"/Users/koro/work/web_my/web_accumulate/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1557296867284}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<h1 id=\\\"js基础-原型、原型链\\\"><a href=\\\"#js基础-原型、原型链\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> JS基础-原型、原型链</h1> <p>JS的原型、原型链一直是比较难理解的内容，不少初学者甚至有一定经验的老鸟都不一定能完全说清楚，更多的&quot;很可能&quot;是一知半解，而这部分内容又是JS的核心内容，想要技术进阶的话肯定不能对这个概念一知半解，碰到问题靠“猜”，却不理解它的规则！</p> <h2 id=\\\"prototype\\\"><a href=\\\"#prototype\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> prototype</h2> <h3 id=\\\"只有函数有prototype属性\\\"><a href=\\\"#只有函数有prototype属性\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 只有函数有prototype属性</h3> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">let</span> a <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token keyword\\\">let</span> <span class=\\\"token function-variable function\\\">b</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span> <span class=\\\"token punctuation\\\">}</span>\\nconsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>a<span class=\\\"token punctuation\\\">.</span>prototype<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// undefined</span>\\nconsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>b<span class=\\\"token punctuation\\\">.</span>prototype<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// { constructor: function(){...} }</span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br></div></div><h4 id=\\\"object-prototype怎么解释？\\\"><a href=\\\"#object-prototype怎么解释？\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Object.prototype怎么解释？</h4> <p>其实<code>Object</code>是一个全局对象，也是一个构造函数，以及其他基本类型的全局对象也都是构造函数：</p> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">outTypeName</span><span class=\\\"token punctuation\\\">(</span>data<span class=\\\"token punctuation\\\">,</span> type<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">let</span> typeName <span class=\\\"token operator\\\">=</span>  Object<span class=\\\"token punctuation\\\">.</span>prototype<span class=\\\"token punctuation\\\">.</span>toString<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">call</span><span class=\\\"token punctuation\\\">(</span>data<span class=\\\"token punctuation\\\">)</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>typeName<span class=\\\"token punctuation\\\">)</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token function\\\">outTypeName</span><span class=\\\"token punctuation\\\">(</span>Object<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">//[object Function]</span>\\n<span class=\\\"token function\\\">outTypeName</span><span class=\\\"token punctuation\\\">(</span>String<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// [object Function]</span>\\n<span class=\\\"token function\\\">outTypeName</span><span class=\\\"token punctuation\\\">(</span>Number<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// [object Function]</span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br></div></div><h3 id=\\\"为什么只有函数有prototype属性\\\"><a href=\\\"#为什么只有函数有prototype属性\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 为什么只有函数有prototype属性</h3> <p>JS通过<code>new</code>来生成对象，但是仅靠构造函数，每次生成的对象都不一样。</p> <p>有时候需要在两个对象之间共享属性，由于JS在设计之初没有类的概念，所以JS使用函数的<code>prototype</code>来处理这部分<strong>需要被共享的属性</strong>，通过函数的<code>prototype</code>来模拟类：</p> <p>当创建一个函数时，JS会自动为函数添加<code>prototype</code>属性，值是一个有<code>constructor</code>的对象。</p> <p>以下是共享属性<code>prototype</code>的栗子：</p> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">People</span><span class=\\\"token punctuation\\\">(</span>name<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>name <span class=\\\"token operator\\\">=</span> name\\n<span class=\\\"token punctuation\\\">}</span>\\nPeople<span class=\\\"token punctuation\\\">.</span>prototype<span class=\\\"token punctuation\\\">.</span>age <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">23</span> <span class=\\\"token comment\\\">// 岁数</span>\\n<span class=\\\"token comment\\\">// 创建两个实例</span>\\n<span class=\\\"token keyword\\\">let</span> People1 <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">People</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'OBKoro1'</span><span class=\\\"token punctuation\\\">)</span>\\n<span class=\\\"token keyword\\\">let</span> People2 <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">People</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'扣肉'</span><span class=\\\"token punctuation\\\">)</span>\\nPeople<span class=\\\"token punctuation\\\">.</span>prototype<span class=\\\"token punctuation\\\">.</span>age <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">24</span> <span class=\\\"token comment\\\">// 长大了一岁</span>\\nconsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>People1<span class=\\\"token punctuation\\\">.</span>age<span class=\\\"token punctuation\\\">,</span> People2<span class=\\\"token punctuation\\\">.</span>age<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// 24 24</span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br><span class=\\\"line-number\\\">9</span><br></div></div><p><strong>为什么<code>People1</code>和<code>People2</code>可以访问到<code>People.prototype.age</code></strong>？</p> <p>原因是：<code>People1</code>和<code>People2</code>的原型是<code>People.prototype</code>，答案在下方的：构造函数是什么以及它做了什么。</p> <h2 id=\\\"原型链\\\"><a href=\\\"#原型链\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 原型链</h2> <h3 id=\\\"proto-和object-getprototypeof-target-：-对象的原型\\\"><a href=\\\"#proto-和object-getprototypeof-target-：-对象的原型\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> <code>__proto__</code>和<code>Object.getPrototypeOf(target)</code>： 对象的原型</h3> <p><code>__proto__</code>是对象实例和它的构造函数之间建立的链接，它的值是：构造函数的`prototype。</p> <p>也就是说：<code>__proto__</code>的值是它所对应的原型对象，是某个函数的<code>prototype</code></p> <p><code>Object.getPrototypeOf(target)</code>全等于<code>__proto__</code>。</p> \"),_vm._ssrNode(\"<p>\",\"</p>\",[_vm._ssrNode(\"它是ES6的标准，兼容IE9，主流浏览器也都支持，\"),_vm._ssrNode(\"<a href=\\\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/GetPrototypeOf#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"MDN\"),_c('OutboundLink')],2),_vm._ssrNode(\"，本文将以<code>Object.getPrototypeOf(target)</code>指代<code>__proto__</code>。\")],2),_vm._ssrNode(\" <h3 id=\\\"不要再使用-proto\\\"><a href=\\\"#不要再使用-proto\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 不要再使用<code>__proto__</code>:</h3> \"),_vm._ssrNode(\"<blockquote>\",\"</blockquote>\",[_vm._ssrNode(\"<p>\",\"</p>\",[_vm._ssrNode(\"本段摘自\"),_vm._ssrNode(\"<a href=\\\"http://es6.ruanyifeng.com/#docs/object-methods#__proto__%E5%B1%9E%E6%80%A7%EF%BC%8CObject-setPrototypeOf%EF%BC%8CObject-getPrototypeOf\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"阮一峰-ES6入门\"),_c('OutboundLink')],2),_vm._ssrNode(\"，具体解析请点击链接查看\")],2)]),_vm._ssrNode(\" <ol><li><p><code>__proto__</code>属性没有写入 ES6 的正文，而是写入了附录。</p></li> <li><p>原因是它本质上是一个内部属性，而<strong>不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6</strong>。</p></li> <li><p>标准明确规定，只有浏览器必须部署这个属性，<strong>其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的</strong>。</p></li> <li><p>所以无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，应该使用：<code>Object.getPrototypeOf(target)</code>（读操作）、<code>Object.setPrototypeOf(target)</code>（写操作）、<code>Object.create(target)</code>（生成操作）代替</p></li></ol> <h3 id=\\\"构造函数是什么、它做了什么\\\"><a href=\\\"#构造函数是什么、它做了什么\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 构造函数是什么、它做了什么</h3> <blockquote><p>出自《你不知道的在js》：在js中, 实际上并不存在所谓的'构造函数'，只有对于函数的'构造调用'。</p></blockquote> <p>上文一直提到构造函数，所谓的构造函数，实际上就是通过关键字<code>new</code>来调用的函数：</p> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">let</span> newObj <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">someFn</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// 构造调用函数</span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br></div></div><p><strong>构造/new调用函数的时候做了什么</strong>：</p> <ol><li>创建一个全新的对象。</li> <li>这个新对象的原型(<code>Object.getPrototypeOf(target)</code>)指向构造函数的<code>prototype</code>对象。</li> <li>该函数的this会绑定在新创建的对象上。</li> <li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li> <li>我们称这个新对象为构造函数的实例。</li></ol> <p><strong>原型继承就是利用构造调用函数的特性</strong>：</p> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code>SubType<span class=\\\"token punctuation\\\">.</span>prototype <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">SuperType</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>  <span class=\\\"token comment\\\">// 原型继承：SubType继承SuperType</span>\\nSubType<span class=\\\"token punctuation\\\">.</span>prototype<span class=\\\"token punctuation\\\">.</span>constructor <span class=\\\"token operator\\\">=</span> SubType <span class=\\\"token comment\\\">// 重新指定constructor指向 方便找到构造函数</span>\\n<span class=\\\"token comment\\\">// 挂载SuperType的this和prototype的属性和方法到SubType.prototype上</span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div><ol><li>\\b构造调用的第二点：将新对象的<code>Object.getPrototypeOf(target)</code>指向函数的<code>prototype</code></li> <li>构造调用的第三点：该函数的this会绑定在新创建的对象上。</li> <li>新对象赋值给<code>SubType.prototype</code></li></ol> <p>原型类型有个缺点：多个实例对引用类型的操作会被篡改。</p> <blockquote><p>因为每次实例化引用类型的数据都指向同一个地址，所以它们读/写的是同一个数据，当一个实例对其进行操作，其他实例的数据就会一起更改。</p></blockquote> <h3 id=\\\"原型链是什么\\\"><a href=\\\"#原型链是什么\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 原型链是什么</h3> <p>来看个例子：</p> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">foo</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span> <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token keyword\\\">const</span> newObj <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">foo</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// 构造调用foo 返回一个新对象</span>\\n<span class=\\\"token keyword\\\">const</span> newObj__proto__ <span class=\\\"token operator\\\">=</span> Object<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getPrototypeOf</span><span class=\\\"token punctuation\\\">(</span>newObj<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// 获取newObj的原型对象</span>\\nnewObj__proto__ <span class=\\\"token operator\\\">===</span> foo<span class=\\\"token punctuation\\\">.</span>prototype <span class=\\\"token comment\\\">// true 验证newObj的原型指向foo</span>\\n<span class=\\\"token keyword\\\">const</span> foo__proto__ <span class=\\\"token operator\\\">=</span> Object<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getPrototypeOf</span><span class=\\\"token punctuation\\\">(</span>foo<span class=\\\"token punctuation\\\">.</span>prototype<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// 获取foo.prototype的原型</span>\\nfoo__proto__ <span class=\\\"token operator\\\">===</span> Object<span class=\\\"token punctuation\\\">.</span>prototype <span class=\\\"token comment\\\">// true foo.prototype的原型是Object.prototype</span>\\n<span class=\\\"token template-string\\\"><span class=\\\"token string\\\">``</span></span>\\n如果用以前的语法，从<span class=\\\"token template-string\\\"><span class=\\\"token string\\\">`newObj`</span></span>查找<span class=\\\"token template-string\\\"><span class=\\\"token string\\\">`foo`</span></span>的原型，是这样的：\\n<span class=\\\"token template-string\\\"><span class=\\\"token string\\\">``</span></span>`js\\nnewObj<span class=\\\"token punctuation\\\">.</span>__proto__<span class=\\\"token punctuation\\\">.</span>__proto__ <span class=\\\"token comment\\\">// 这种关系就是原型链</span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br><span class=\\\"line-number\\\">9</span><br><span class=\\\"line-number\\\">10</span><br></div></div><p><strong>可以用以下三句话来理解原型链</strong>：</p> <ol><li><strong>每个对象都拥有一个原型对象</strong>: <code>newObj</code>的原型是<code>foo.prototype</code>。</li> <li><strong>对象的原型可能也是继承其他原型对象的</strong>: <code>foo.prototype</code>也有它的原型<code>Object.prototype</code>。</li> <li><strong>一层一层的，以此类推，这种关系就是原型链</strong>。</li></ol> <h3 id=\\\"一个对象是否在另一个对象的原型链上\\\"><a href=\\\"#一个对象是否在另一个对象的原型链上\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 一个对象是否在另一个对象的原型链上</h3> <blockquote><p>如果一个对象存在另一个对象的原型链上，我们可以说：它们是继承关系。</p></blockquote> <p>判断方式有两种，但都是根据构造函数的<code>prototype</code>是否在原型链上来判断的：</p> <ol><li><code>instanceof</code>: 用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置</li></ol> <p>语法：<code>object instanceof constructor</code></p> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">let</span> <span class=\\\"token function-variable function\\\">test</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span> <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token keyword\\\">let</span> testObject <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">test</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\ntestObject <span class=\\\"token keyword\\\">instanceof</span> <span class=\\\"token class-name\\\">test</span> <span class=\\\"token comment\\\">// true test.prototype在testObject的原型链上</span>\\n testObject <span class=\\\"token keyword\\\">instanceof</span> <span class=\\\"token class-name\\\">Function</span> <span class=\\\"token comment\\\">// false Function.prototype 不在testObject的原型链上</span>\\ntestObject <span class=\\\"token keyword\\\">instanceof</span> <span class=\\\"token class-name\\\">Object</span> <span class=\\\"token comment\\\">// true Object.prototype在testObject的原型链上</span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br></div></div><ol start=\\\"2\\\"><li><code>isPrototypeOf</code>：测试一个对象是否存在于另一个对象的原型链上</li></ol> <p>语法：<code>prototypeObj.isPrototypeOf(object)</code></p> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">let</span> <span class=\\\"token function-variable function\\\">test</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span> <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token keyword\\\">let</span> testObject <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">test</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\ntest<span class=\\\"token punctuation\\\">.</span>prototype<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">isPrototypeOf</span><span class=\\\"token punctuation\\\">(</span>testObject<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// true test.prototype在testObject的原型链上</span>\\nObject<span class=\\\"token punctuation\\\">.</span>prototype<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">isPrototypeOf</span><span class=\\\"token punctuation\\\">(</span>testObject<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// true Object.prototype在testObject的原型链上</span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br></div></div><h3 id=\\\"原型链的终点-object-prototype\\\"><a href=\\\"#原型链的终点-object-prototype\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 原型链的终点: <code>Object.prototype</code></h3> <p><code>Object.prototype</code>是原型链的终点，所有对象都是从它继承了方法和属性。</p> <p><strong><code>Object.prototype</code>没有原型对象</strong>：</p> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">const</span> proto <span class=\\\"token operator\\\">=</span> Object<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getPrototypeOf</span><span class=\\\"token punctuation\\\">(</span>Object<span class=\\\"token punctuation\\\">.</span>prototype<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// null</span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br></div></div><p>下面是两个验证例子，有疑虑的同学多写几个测试用例印证一下。</p> <p><strong>字符串原型链的终点</strong>：<code>Object.prototype</code></p> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">let</span> test <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'由String函数构造出来的'</span>\\n<span class=\\\"token keyword\\\">let</span> stringPrototype <span class=\\\"token operator\\\">=</span> Object<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getPrototypeOf</span><span class=\\\"token punctuation\\\">(</span>test<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// 字符串的原型</span>\\nstringPrototype <span class=\\\"token operator\\\">===</span> String<span class=\\\"token punctuation\\\">.</span>prototype <span class=\\\"token comment\\\">// true 字符串的原型是String对象</span>\\nObject<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getPrototypeOf</span><span class=\\\"token punctuation\\\">(</span>stringPrototype<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">===</span> Object<span class=\\\"token punctuation\\\">.</span>prototype <span class=\\\"token comment\\\">// true String对象的原型是Object对象</span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br></div></div><p><strong>函数原型链的终点</strong>:<code>Object.prototype</code></p> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">let</span> <span class=\\\"token function-variable function\\\">test</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span> <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token keyword\\\">let</span> fnPrototype <span class=\\\"token operator\\\">=</span> Object<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getPrototypeOf</span><span class=\\\"token punctuation\\\">(</span>test<span class=\\\"token punctuation\\\">)</span>\\nfnPrototype <span class=\\\"token operator\\\">===</span> Function<span class=\\\"token punctuation\\\">.</span>prototype <span class=\\\"token comment\\\">// true test的原型是Function.prototype</span>\\nObject<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getPrototypeOf</span><span class=\\\"token punctuation\\\">(</span>Function<span class=\\\"token punctuation\\\">.</span>prototype<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">===</span> Object<span class=\\\"token punctuation\\\">.</span>prototype <span class=\\\"token comment\\\">// true</span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br></div></div><h3 id=\\\"原型链用来做什么？\\\"><a href=\\\"#原型链用来做什么？\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 原型链用来做什么？</h3> <h4 id=\\\"属性查找：\\\"><a href=\\\"#属性查找：\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 属性查找：</h4> <blockquote><p>如果试图访问对象(实例instance)的某个属性,会首先在对象内部寻找该属性,直至找不到,然后才在该对象的原型(instance.prototype)里去找这个属性，以此类推</p></blockquote> <p>我们用一个例子来形象说明一下：</p> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">let</span> test <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'由String函数构造出来的'</span>\\n<span class=\\\"token keyword\\\">let</span> stringPrototype <span class=\\\"token operator\\\">=</span> Object<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getPrototypeOf</span><span class=\\\"token punctuation\\\">(</span>test<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// 字符串的原型</span>\\nstringPrototype <span class=\\\"token operator\\\">===</span> String<span class=\\\"token punctuation\\\">.</span>prototype <span class=\\\"token comment\\\">// true 字符串的原型是String对象</span>\\nObject<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getPrototypeOf</span><span class=\\\"token punctuation\\\">(</span>stringPrototype<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">===</span> Object<span class=\\\"token punctuation\\\">.</span>prototype <span class=\\\"token comment\\\">// true String对象的原型是Object对象</span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br></div></div><p>当你访问<code>test</code>的某个属性时，浏览器会进行以下查找：</p> <ol><li>浏览器首先查找<code>test</code> 本身</li> <li>接着查找它的原型对象：<code>String.prototype</code></li> <li>最后查找<code>String.prototype</code>的原型对象：<code>Object.prototype</code></li> <li>一旦在原型链上找到该属性，就会立即返回该属性，停止查找。</li> <li>原型链上的原型都没有找到的话，返回<code>undefiend</code></li></ol> <p>这种查找机制还解释了字符串为何会有自带的方法: <code>slice</code>/<code>split</code>/<code>indexOf</code>等。</p> <p>准确的说：</p> <ul><li>这些属性和方法是定义在<code>String</code>这个全局对象/函数上的。</li> <li>字符串的原型指向了<code>String</code>函数的<code>prototype</code>。</li> <li>之后通过查找原型链，在String函数的<code>prototype</code>中找到这些属性和方法。</li></ul> <h4 id=\\\"拒绝查找原型链：\\\"><a href=\\\"#拒绝查找原型链：\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 拒绝查找原型链：</h4> <p><code>hasOwnProperty</code>: 指示对象自身属性中是否具有指定的属性</p> <p>语法：<code>obj.hasOwnProperty(prop)</code></p> <p>参数: <code>prop</code> 要查找的属性</p> <p>返回值: 用来判断某个对象是否含有指定的属性的<code>Boolean</code>。</p> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">let</span> test <span class=\\\"token operator\\\">=</span><span class=\\\"token punctuation\\\">{</span> <span class=\\\"token string\\\">'OBKoro1'</span><span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'扣肉'</span> <span class=\\\"token punctuation\\\">}</span>\\ntest<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">hasOwnProperty</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'OBKoro1'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>  <span class=\\\"token comment\\\">// true</span>\\ntest<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">hasOwnProperty</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'toString'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// false test本身没查找到toString </span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div><p>这个<code>API</code>是挂载在<code>object.prototype</code>上，所有对象都可以使用，API会忽略掉那些从原型链上继承到的属性。</p> <h2 id=\\\"扩展：\\\"><a href=\\\"#扩展：\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 扩展：</h2> <h3 id=\\\"实例的属性\\\"><a href=\\\"#实例的属性\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 实例的属性</h3> <p>你知道构造函数的实例对象上有哪些属性吗？这些属性分别挂载在哪个地方？原因是什么？</p> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">foo</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>some <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'222'</span>\\n    <span class=\\\"token keyword\\\">let</span> ccc <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'ccc'</span>\\n    foo<span class=\\\"token punctuation\\\">.</span>obkoro1 <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'obkoro1'</span>\\n    foo<span class=\\\"token punctuation\\\">.</span>prototype<span class=\\\"token punctuation\\\">.</span>a <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'aaa'</span>\\n<span class=\\\"token punctuation\\\">}</span>\\nfoo<span class=\\\"token punctuation\\\">.</span>koro <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'扣肉'</span>\\nfoo<span class=\\\"token punctuation\\\">.</span>prototype<span class=\\\"token punctuation\\\">.</span>test <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'test'</span>\\n<span class=\\\"token keyword\\\">let</span> foo1 <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">foo</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// `foo1`上有哪些属性,这些属性分别挂载在哪个地方</span>\\nfoo<span class=\\\"token punctuation\\\">.</span>prototype<span class=\\\"token punctuation\\\">.</span>test <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'test2'</span> <span class=\\\"token comment\\\">// 重新赋值</span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br><span class=\\\"line-number\\\">9</span><br><span class=\\\"line-number\\\">10</span><br></div></div><p>上面这道是考察<code>JS</code>基础的题，很多人都没说对，原因是没有彻底掌握<code>this</code>、<code>原型链</code>、<code>函数</code>。</p> <h4 id=\\\"想一下再看解析：\\\"><a href=\\\"#想一下再看解析：\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 想一下再看解析：</h4> <h4 id=\\\"想一下再看解析：-2\\\"><a href=\\\"#想一下再看解析：-2\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 想一下再看解析：</h4> <h4 id=\\\"想一下再看解析：-3\\\"><a href=\\\"#想一下再看解析：-3\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 想一下再看解析：</h4> <h4 id=\\\"想一下再看解析：-4\\\"><a href=\\\"#想一下再看解析：-4\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 想一下再看解析：</h4> <h4 id=\\\"想一下再看解析：-5\\\"><a href=\\\"#想一下再看解析：-5\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 想一下再看解析：</h4> <ol><li><code>this.some</code>：<code>foo1</code>对象的属性</li></ol> <p>通过构造调用<code>foo</code>的<code>this</code>指向<code>foo1</code>，所以<code>this.some</code>挂载在<code>foo1</code>对象下。</p> <p>属性查找: <code>foo1.some</code></p> <p><code>foo1.some</code>直接读取<code>foo1</code>的属性。</p> <ol start=\\\"2\\\"><li><code>foo1.test</code>、<code>foo1.a</code>：<code>foo1</code>对象的原型</li></ol> <p>根据上文提到的：构造/new调用函数的时候会创建一个新对象(<code>foo1</code>)，自动将<code>foo1</code>的原型(<code>Object.getPrototypeOf(foo1)</code>)指向构造函数的prototype对象。</p> <p>构造调用会执行函数，所以<code>foo.prototype.a = 'aaaaa'</code>也会执行，单就赋值这个层面来说写在<code>foo</code>外面和写在<code>foo</code>里面是一样的。</p> <p>属性查找：<code>foo1.test</code>、<code>foo1.a</code></p> <ul><li><code>foo1</code>本身没有找到,继续查找</li> <li><code>foo1</code>的原型<code>Object.getPrototypeOf(foo1)</code>上找到了<code>a</code>和<code>test</code>，返回它们，停止查找。</li></ul> <ol start=\\\"3\\\"><li><code>foo1.obkoro1</code>和<code>foo1.koro</code>：返回undefined</li></ol> <h4 id=\\\"静态属性-foo-obkoro1、foo-koro\\\"><a href=\\\"#静态属性-foo-obkoro1、foo-koro\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 静态属性: <code>foo.obkoro1</code>、<code>foo.koro</code></h4> <blockquote><p>函数在JS中是一等公民，它也是一个对象, 用来模拟类。</p></blockquote> <p>这两个属性跟<code>foo1</code>没有关系，它是对象<code>foo</code>上的两个属性(类似函数的:<code>arguments</code>/<code>prototype</code>/<code>length</code>等属性)，称为<strong>静态属性</strong>。</p> <p>它们只能通过<code>foo.obkoro1</code>和<code>foo.koro</code>来访问。</p> <h4 id=\\\"原型对象改变，原型链下游获取的值也会改变\\\"><a href=\\\"#原型对象改变，原型链下游获取的值也会改变\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 原型对象改变，原型链下游获取的值也会改变</h4> <p>上面那个例子中的<code>foo1.test</code>的值是什么？</p> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code>foo<span class=\\\"token punctuation\\\">.</span>prototype<span class=\\\"token punctuation\\\">.</span>test <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'test'</span>\\n<span class=\\\"token keyword\\\">let</span> foo1 <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">foo</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// `foo1`上有哪些属性,这些属性分别挂载在哪个地方</span>\\nfoo<span class=\\\"token punctuation\\\">.</span>prototype<span class=\\\"token punctuation\\\">.</span>test <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'test2'</span> <span class=\\\"token comment\\\">// 重新赋值</span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div><p><code>foo1.test</code>的值是<code>test2</code>，原因是：<code>foo1</code>的原型对象是<code>Object.getPrototypeOf(foo1)</code>存的指针，指向<code>foo.prototype</code>的内存地址，不是拷贝，每次读取的值都是当前<code>foo.prototype</code>的最新值。</p> <p><strong>打印<code>foo1</code></strong>：</p> <p><img src=\\\"https://github.com/OBKoro1/articleImg_src/blob/master/2019/2019_8_25_prototype.png?raw=true\\\" alt></p> <h3 id=\\\"小结\\\"><a href=\\\"#小结\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 小结</h3> <p>写了好几天，之前网上很多图文博客，那些线指来指去，就我个人看来还是比较难以理解的，所以本文纯文字的形式来描述这些概念，相信认真看完的同学肯定都有所收获，如果没看懂的话，建议多看几遍，这部分概念真的很重要！</p> <p>PS：实际上还有很多引申出来的东西没写全，准备放到其他文章中去写。</p> \"),_vm._ssrNode(\"<h4 id=\\\"觉得我的博客对你有帮助的话，就给我点个star吧！\\\">\",\"</h4>\",[_vm._ssrNode(\"<a href=\\\"#觉得我的博客对你有帮助的话，就给我点个star吧！\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 觉得我的博客对你有帮助的话，就给我点个\"),_vm._ssrNode(\"<a href=\\\"https://github.com/OBKoro1/web_accumulate\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"Star\"),_c('OutboundLink')],2),_vm._ssrNode(\"吧！\")],2),_vm._ssrNode(\" \"),_vm._ssrNode(\"<p>\",\"</p>\",[_vm._ssrNode(\"<a href=\\\"http://obkoro1.com/web_accumulate/\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"前端进阶积累\"),_c('OutboundLink')],2),_vm._ssrNode(\"、\"),_vm._ssrNode(\"<a href=\\\"https://user-gold-cdn.xitu.io/2018/5/1/1631b6f52f7e7015?w=344&h=344&f=jpeg&s=8317\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"公众号\"),_c('OutboundLink')],2),_vm._ssrNode(\"、\"),_vm._ssrNode(\"<a href=\\\"https://github.com/OBKoro1\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"GitHub\"),_c('OutboundLink')],2),_vm._ssrNode(\"、wx:OBkoro1、邮箱：obkoro1@foxmail.com\")],2),_vm._ssrNode(\" <p>以上2019/8/25</p> \"),_vm._ssrNode(\"<p>\",\"</p>\",[_vm._ssrNode(\"作者：\"),_vm._ssrNode(\"<a href=\\\"https://github.com/OBKoro1\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"OBKoro1\"),_c('OutboundLink')],2)],2),_vm._ssrNode(\" <p>参考资料：</p> \"),_vm._ssrNode(\"<p>\",\"</p>\",[_vm._ssrNode(\"<a href=\\\"https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"MDN:对象原型\"),_c('OutboundLink')],2)]),_vm._ssrNode(\" \"),_vm._ssrNode(\"<p>\",\"</p>\",[_vm._ssrNode(\"<a href=\\\"https://juejin.im/post/58f94c9bb123db411953691b#heading-14\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"JS原型链与继承别再被问倒了\"),_c('OutboundLink')],2)]),_vm._ssrNode(\" \"),_vm._ssrNode(\"<p>\",\"</p>\",[_vm._ssrNode(\"<a href=\\\"https://github.com/creeperyang/blog/issues/9\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"从__proto__和prototype来深入理解JS对象和原型链\"),_c('OutboundLink')],2)]),_vm._ssrNode(\" \"),_vm._ssrNode(\"<h3 id=\\\"点个star支持我一下\\\">\",\"</h3>\",[_vm._ssrNode(\"<a href=\\\"#点个star支持我一下\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 点个\"),_vm._ssrNode(\"<a href=\\\"https://github.com/OBKoro1/web_accumulate\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"Star\"),_c('OutboundLink')],2),_vm._ssrNode(\"支持我一下~\")],2),_vm._ssrNode(\" \"),_c('comment-comment')],2)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}