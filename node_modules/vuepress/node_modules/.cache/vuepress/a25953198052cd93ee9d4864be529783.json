{"remainingRequest":"/Users/koro/work/web_my/web_accumulate/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/koro/work/web_my/web_accumulate/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/koro/work/web_my/web_accumulate/docs/accumulate/ES6/js调用栈机制与ES6尾调用优化介绍.md?vue&type=template&id=c2c4835a&","dependencies":[{"path":"/Users/koro/work/web_my/web_accumulate/docs/accumulate/ES6/js调用栈机制与ES6尾调用优化介绍.md","mtime":1636107879468},{"path":"/Users/koro/work/web_my/web_accumulate/node_modules/cache-loader/dist/cjs.js","mtime":1557296864520},{"path":"/Users/koro/work/web_my/web_accumulate/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1557296867191},{"path":"/Users/koro/work/web_my/web_accumulate/node_modules/cache-loader/dist/cjs.js","mtime":1557296864520},{"path":"/Users/koro/work/web_my/web_accumulate/node_modules/vue-loader/lib/index.js","mtime":1557296867190},{"path":"/Users/koro/work/web_my/web_accumulate/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1557296867284}],"contextDependencies":[],"result":["\n<div class=\"content\"><h2 id=\"js-调用栈机制与es6尾调用优化介绍\"><a class=\"header-anchor\" href=\"#js-调用栈机制与es6尾调用优化介绍\" aria-hidden=\"true\">#</a> js 调用栈机制与ES6尾调用优化介绍</h2>\n<p>调用栈的英文名叫做Call Stack，大家或多或少是有听过的，但是对于js调用栈的工作方式以及如何在工作中利用这一特性，大部分人可能没有进行过更深入的研究，这块内容可以说对我们前端来说就是所谓的基础知识，咋一看好像用处并没有很大，但掌握好这个知识点，就可以让我们在以后可以走的更远，走的更快！</p>\n<blockquote>\n<p><a href=\"http://obkoro1.com/\" target=\"_blank\" rel=\"noopener noreferrer\">博客<OutboundLink/></a>、<a href=\"http://obkoro1.com/web_accumulate/accumulate/\" target=\"_blank\" rel=\"noopener noreferrer\">前端积累文档<OutboundLink/></a>、<a href=\"https://github.com/OBKoro1/articleImg_src/blob/master/juejin/1631b6f52f7e7015.jpeg?raw=true\" target=\"_blank\" rel=\"noopener noreferrer\">公众号<OutboundLink/></a>、<a href=\"https://github.com/OBKoro1\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub<OutboundLink/></a></p>\n</blockquote>\n<hr>\n<h3 id=\"目录\"><a class=\"header-anchor\" href=\"#目录\" aria-hidden=\"true\">#</a> 目录</h3>\n<ol>\n<li>数据结构：栈</li>\n<li>调用栈是什么？用来做什么？</li>\n<li>调用栈的运行机制</li>\n<li>调用栈优化内存</li>\n<li>调用栈debug大法</li>\n</ol>\n<h3 id=\"数据结构：栈\"><a class=\"header-anchor\" href=\"#数据结构：栈\" aria-hidden=\"true\">#</a> 数据结构：栈</h3>\n<p>栈是一种遵从<strong>后进先出(<code>LIFO</code>)原则的有序集合</strong>，新元素都靠近栈顶，旧元素都接近栈底。</p>\n<p>生活中的栗子，帮助一下理解：</p>\n<p>餐厅里面堆放的盘子(栈)，一开始放的都在下面(先进)，后面放的都在上面(后进)，洗盘子的时候先从上面开始洗(先出)。</p>\n<h3 id=\"调用栈是什么？用来做什么？\"><a class=\"header-anchor\" href=\"#调用栈是什么？用来做什么？\" aria-hidden=\"true\">#</a> 调用栈是什么？用来做什么？</h3>\n<ol>\n<li><strong>调用栈是一种栈结构的数据，它是由调用侦组成的</strong>。</li>\n<li><strong>调用栈记录了函数的执行顺序和函数内部变量等信息</strong>。</li>\n</ol>\n<h4 id=\"调用栈的运行机制\"><a class=\"header-anchor\" href=\"#调用栈的运行机制\" aria-hidden=\"true\">#</a> 调用栈的运行机制</h4>\n<p><strong>机制</strong>：</p>\n<p>程序运行到一个函数，它就会将其添加到调用栈中，当从这个函数返回的时候，就会将这个函数从调用栈中删掉。</p>\n<p>看一下例子帮助理解：</p>\n<!--beforebegin--><div class=\"language-js line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token comment\">// 调用栈中的执行步骤用数字表示</span>\n<span class=\"token function\">printSquare</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1 添加</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">printSquare</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> s <span class=\"token operator\">=</span> <span class=\"token function\">multiply</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 2 添加 => 3 运行完成，内部没有再调用其他函数，删掉</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 4 添加 => 5 删掉</span>\n    <span class=\"token comment\">// 运行完成 删掉printSquare</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">multiply</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> x <span class=\"token operator\">*</span> y<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br><span class=\"line-number\">6</span><br><span class=\"line-number\">7</span><br><span class=\"line-number\">8</span><br><span class=\"line-number\">9</span><br><span class=\"line-number\">10</span><br></div><!--beforeend--></div><!--afterend--><p>调用栈中的执行步骤如下(删除multiply的步骤被省略了)：</p>\n<p><img src=\"https://github.com/OBKoro1/articleImg_src/blob/master/juejin/16acb4a439190d49?raw=true\" alt=\"\"></p>\n<p><strong>调用侦</strong>：</p>\n<p>每个进入到调用栈中的函数，都会分配到一个单独的栈空间，称为“调用侦”。</p>\n<p>在调用栈中每个“调用侦”都对应一个函数，最上方的调用帧称为“当前帧”，调用栈是由所有的调用侦形成的。</p>\n<p>找到一张图片，调用侦：</p>\n<p><img src=\"https://github.com/OBKoro1/articleImg_src/blob/master/juejin/16ace8030a36c8dd?raw=true\" alt=\"\"></p>\n<h3 id=\"调用栈优化内存\"><a class=\"header-anchor\" href=\"#调用栈优化内存\" aria-hidden=\"true\">#</a> 调用栈优化内存</h3>\n<p><strong>调用栈的内存消耗</strong>：</p>\n<p>如上图，函数的变量等信息会被调用侦保存起来，所以<strong>调用侦中的变量不会被垃圾收集器回收</strong>。</p>\n<p>当函数嵌套的层级比较深了，调用栈中的调用侦比较多的时候，这些信息对内存消耗是非常大的。</p>\n<p>针对这种情况除了我们要尽量避免函数层级嵌套的比较深之外，ES6提供了“尾调用优化”来解决调用侦过多，引起的内存消耗过大的问题。</p>\n<p><strong>何谓尾调用</strong>：</p>\n<p>尾调用指的是：<strong>函数的最后一步是调用另一个函数</strong>。</p>\n<!--beforebegin--><div class=\"language-js line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 最后一步调用另一个函数并且使用return</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function\">g</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 没有return 不算尾调用 因为不知道后面还有没有操作</span>\n  <span class=\"token comment\">// return undefined; // 隐式的return</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br><span class=\"line-number\">6</span><br><span class=\"line-number\">7</span><br></div><!--beforeend--></div><!--afterend--><p><strong>尾调用优化优化了什么？</strong></p>\n<p>尾调用用来<strong>删除外层无用的调用侦</strong>，只保留内层函数的调用侦，来节省浏览器的内存。</p>\n<p>下面这个例子调用栈中的调用侦一直只有一项，如果不使用尾调用的话会出现三个调用侦：</p>\n<!--beforebegin--><div class=\"language-js line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 1 添加a到调用栈</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 在调用栈中删除a 添加b</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">c</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 删除b 添加c</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br><span class=\"line-number\">6</span><br><span class=\"line-number\">7</span><br></div><!--beforeend--></div><!--afterend--><p><strong>防止爆栈</strong>：</p>\n<p>浏览器对<a href=\"https://codeday.me/bug/20170824/62171.html\" target=\"_blank\" rel=\"noopener noreferrer\">调用栈都有大小限制<OutboundLink/></a>，在ES6之前递归比较深的话，很容易出现“爆栈”问题(stack overflow)。</p>\n<p>现在可以使用“尾调用优化”来写一个“尾递归”，只保存一个调用侦，来防止爆栈问题。</p>\n<p><strong>注意</strong>：</p>\n<ol>\n<li>只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧。</li>\n</ol>\n<blockquote>\n<p>如果要使用外层函数的变量，可以通过参数的形式传到内层函数中</p>\n</blockquote>\n<!--beforebegin--><div class=\"language-js line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> aa <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> <span class=\"token function-variable function\">b</span> <span class=\"token operator\">=</span> val <span class=\"token operator\">=></span> aa <span class=\"token operator\">+</span> val <span class=\"token comment\">// 使用了外层函数的参数aa</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 无法进行尾调用优化</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br></div><!--beforeend--></div><!--afterend--><ol start=\"2\">\n<li>尾调用优化只在严格模式下开启，非严格模式是无效的。</li>\n<li>如果环境不支持“尾调用优化”，代码还可以正常运行，是无害的！</li>\n</ol>\n<p><strong>更多</strong>：</p>\n<p>关于尾递归以及更多尾调用优化的内容，推荐查阅<a href=\"http://es6.ruanyifeng.com/#docs/function#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96\" target=\"_blank\" rel=\"noopener noreferrer\">ES6入门-阮一峰<OutboundLink/></a></p>\n<h3 id=\"调用栈debug大法\"><a class=\"header-anchor\" href=\"#调用栈debug大法\" aria-hidden=\"true\">#</a> 调用栈debug大法</h3>\n<p><strong>查看调用栈有什么用</strong></p>\n<ol>\n<li>\n<p>查看函数的调用顺序是否跟预期一致，比如不同判断调用不同函数。</p>\n</li>\n<li>\n<p>快速定位问题/修改三方库的代码。</p>\n<p>当接手一个历史项目，或者引用第三方库出现问题的时候，可以先查看对应API的调用栈，找到其中涉及的关键函数，针对性的修复它。</p>\n<p>通过查看调用栈的形式，帮助我快速定位问题，修改三方库的源码。</p>\n</li>\n</ol>\n<p><strong>如何查看调用栈</strong></p>\n<ol>\n<li>只查看调用栈：<code>console.trace</code></li>\n</ol>\n<!--beforebegin--><div class=\"language-js line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">c</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">c</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> aa <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">trace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br><span class=\"line-number\">6</span><br><span class=\"line-number\">7</span><br><span class=\"line-number\">8</span><br><span class=\"line-number\">9</span><br><span class=\"line-number\">10</span><br><span class=\"line-number\">11</span><br></div><!--beforeend--></div><!--afterend--><p>如图所示,点击右侧还能查看代码位置：</p>\n<p><img src=\"https://github.com/OBKoro1/articleImg_src/blob/master/juejin/16ad3f508ab127a9?raw=true\" alt=\"\"></p>\n<ol start=\"2\">\n<li><code>bugger</code>打断点形式，这也是我最喜欢的调试方式：</li>\n</ol>\n<p><img src=\"https://github.com/OBKoro1/articleImg_src/blob/master/juejin/16ad3ff354f2dac3?raw=true\" alt=\"\"></p>\n<h2 id=\"结语\"><a class=\"header-anchor\" href=\"#结语\" aria-hidden=\"true\">#</a> 结语</h2>\n<p>本文主要讲了这几个方面的内容：</p>\n<ol>\n<li>理解调用栈的运行机制，对代码背后的一些执行机制也可以更加了解，帮助我们在百尺竿头更进一步。</li>\n<li>我们应该在日常的code中，有意识的使用ES6的“尾调用优化”，来减少调用栈的长度，节省客户端内存。</li>\n<li>利用调用栈，对第三方库或者不熟悉的项目，可以更快速的定位问题，提高我们debug速度。</li>\n</ol>\n<p>最后：之前写过一篇关于<a href=\"https://juejin.im/post/5b40581e5188251ac446c716\" target=\"_blank\" rel=\"noopener noreferrer\">垃圾回收机制与内存泄露<OutboundLink/></a>的文章，感兴趣的同学可以扩展一下。</p>\n<p>以上2019/5/19</p>\n<p>参考资料：</p>\n<p><a href=\"https://juejin.im/post/5b40581e5188251ac446c716\" target=\"_blank\" rel=\"noopener noreferrer\">JS垃圾回收机制与常见内存泄露的解决方法<OutboundLink/></a></p>\n<p><a href=\"http://es6.ruanyifeng.com/#docs/function#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96\" target=\"_blank\" rel=\"noopener noreferrer\">ES6入门-阮一峰<OutboundLink/></a></p>\n<p><a href=\"https://juejin.im/post/5a05b4576fb9a04519690d42\" target=\"_blank\" rel=\"noopener noreferrer\">JavaScript 如何工作：对引擎、运行时、调用堆栈的概述<OutboundLink/></a></p>\n<p><a href=\"https://segmentfault.com/a/1190000010360316\" target=\"_blank\" rel=\"noopener noreferrer\">浅析javascript调用栈<OutboundLink/></a>\n<!-- 特殊字符串：用于修改/删除markdown的结尾提示语-OBKoro1 --></p>\n<h3 id=\"点个star支持我一下\"><a class=\"header-anchor\" href=\"#点个star支持我一下\" aria-hidden=\"true\">#</a> 点个<a href=\"https://github.com/OBKoro1/web_accumulate\" target=\"_blank\" rel=\"noopener noreferrer\">Star<OutboundLink/></a>支持我一下~</h3>\n<!-- '特殊字符串：用于删除编译后的issue组件-OBKoro1 -->\n<!-- more -->\n<comment-comment/>\n</div>\n",null]}