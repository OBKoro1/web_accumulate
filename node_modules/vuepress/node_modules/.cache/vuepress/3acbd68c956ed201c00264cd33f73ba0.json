{"remainingRequest":"/Users/huangguobao/work/web_my/web_accumulate/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/huangguobao/work/web_my/web_accumulate/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/huangguobao/work/web_my/web_accumulate/docs/accumulate/tool/js垃圾回收机制.md?vue&type=template&id=6d4c7d99&","dependencies":[{"path":"/Users/huangguobao/work/web_my/web_accumulate/docs/accumulate/tool/js垃圾回收机制.md","mtime":1559195331882},{"path":"/Users/huangguobao/work/web_my/web_accumulate/node_modules/cache-loader/dist/cjs.js","mtime":1548245069428},{"path":"/Users/huangguobao/work/web_my/web_accumulate/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1548245072336},{"path":"/Users/huangguobao/work/web_my/web_accumulate/node_modules/cache-loader/dist/cjs.js","mtime":1548245069428},{"path":"/Users/huangguobao/work/web_my/web_accumulate/node_modules/vue-loader/lib/index.js","mtime":1548245072335},{"path":"/Users/huangguobao/work/web_my/web_accumulate/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1548245072442}],"contextDependencies":[],"result":["\n<div class=\"content\"><h2 id=\"js高程中的垃圾回收机制与常见内存泄露的解决方法\"><a class=\"header-anchor\" href=\"#js高程中的垃圾回收机制与常见内存泄露的解决方法\" aria-hidden=\"true\">#</a> JS高程中的垃圾回收机制与常见内存泄露的解决方法</h2>\n<p>起因是因为想了解闭包的内存泄露机制，然后想起《js高级程序设计》中有关于垃圾回收机制的解析，之前没有很懂，过一年回头再看就懂了，写篇博客与大家分享一下。</p>\n<h3 id=\"内存的生命周期：\"><a class=\"header-anchor\" href=\"#内存的生命周期：\" aria-hidden=\"true\">#</a> 内存的生命周期：</h3>\n<ol>\n<li>分配你所需要的内存：</li>\n</ol>\n<p>由于字符串、对象等没有固定的大小，js程序在每次创建字符串、对象的时候，程序都会<strong>分配内存来存储那个实体</strong>。</p>\n<ol start=\"2\">\n<li>\n<p>使用分配到的内存做点什么。</p>\n</li>\n<li>\n<p>不需要时将其释放回归：</p>\n</li>\n</ol>\n<p>在不需要字符串、对象的时候，需要释放其所占用的内存，否则将会消耗完系统中所有可用的内存，造成系统崩溃，这就是<strong>垃圾回收机制所存在的意义</strong>。</p>\n<p><strong>所谓的内存泄漏指的是</strong>：由于疏忽或错误造成程序未能释放那些已经不再使用的内存，造成内存的浪费。</p>\n<hr>\n<h2 id=\"垃圾回收机制：\"><a class=\"header-anchor\" href=\"#垃圾回收机制：\" aria-hidden=\"true\">#</a> 垃圾回收机制：</h2>\n<p>在C和C++之类的语言中，需要手动来管理内存的，这也是造成许多不必要问题的根源。幸运的是，在编写js的过程中，内存的分配以及内存的回收完全实现了自动管理，我们不用操心这种事情。</p>\n<h3 id=\"垃圾收集机制的原理：\"><a class=\"header-anchor\" href=\"#垃圾收集机制的原理：\" aria-hidden=\"true\">#</a> 垃圾收集机制的原理：</h3>\n<p>垃圾收集器会按照固定的时间间隔，<strong>周期性的找出不再继续使用的变量，然后释放其占用的内存</strong>。</p>\n<p><strong>什么叫不再继续使用的变量？</strong></p>\n<p>不再使用的变量也就是生命周期结束的变量，是局部变量，局部变量只在函数的执行过程中存在，当函数运行结束，没有其他引用(闭包)，那么该变量会被标记回收。</p>\n<p>全局变量的生命周期直至浏览器卸载页面才会结束，也就是说<strong>全局变量不会被当成垃圾回收</strong>。</p>\n<h3 id=\"标记清除：当前采用的垃圾收集策略\"><a class=\"header-anchor\" href=\"#标记清除：当前采用的垃圾收集策略\" aria-hidden=\"true\">#</a> 标记清除：当前采用的垃圾收集策略</h3>\n<p>工作原理：</p>\n<p>当变量进入环境时(例如在函数中声明一个变量)，将这个变量标记为“进入环境”，当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。</p>\n<p>工作流程：</p>\n<ol>\n<li>垃圾收集器会在运行的时候会给存储在内存中的<strong>所有变量都加上标记</strong>。</li>\n<li><strong>去掉环境中的变量</strong>以及被环境中的变量引用的变量的标记。</li>\n<li>那些<strong>还存在标记的变量被视为准备删除的变量</strong>。</li>\n<li>最后垃圾收集器会执行最后一步内存清除的工作，<strong>销毁那些带标记的值并回收它们所占用的内存空间</strong>。</li>\n</ol>\n<p>到2008年为止,IE、Chorme、Fireofx、Safari、Opera <strong>都使用标记清除式的垃圾收集策略</strong>，只不过垃圾收集的时间间隔互有不同。</p>\n<h3 id=\"引用计数略：被废弃的垃圾收集策略\"><a class=\"header-anchor\" href=\"#引用计数略：被废弃的垃圾收集策略\" aria-hidden=\"true\">#</a> 引用计数略：被废弃的垃圾收集策略</h3>\n<p>循环引用：跟踪记录每个值被引用的技术</p>\n<p>在老版本的浏览器中(对，又是IE)，IE9以下BOM和DOM对象就是使用C++以COM对象的形式实现的。</p>\n<p>COM的垃圾收集机制采用的就是引用计数策略，这种机制在出现循环引用的时候永远都释放不掉内存。</p>\n<!--beforebegin--><div class=\"language-js line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">let</span> element <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'something'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> myObject <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmyObject<span class=\"token punctuation\">.</span>element <span class=\"token operator\">=</span> element<span class=\"token punctuation\">;</span> <span class=\"token comment\">// element属性指向dom</span>\nelement<span class=\"token punctuation\">.</span>someThing <span class=\"token operator\">=</span> myObject<span class=\"token punctuation\">;</span> <span class=\"token comment\">// someThing回指myObject 出现循环引用(两个对象一直互相包含 一直存在计数)。</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br></div><!--beforeend--></div><!--afterend--><p>解决方式是，当我们不使用它们的时候，手动切断链接：</p>\n<!--beforebegin--><div class=\"language-js line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-js\"><code>myObject<span class=\"token punctuation\">.</span>element <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> \nelement<span class=\"token punctuation\">.</span>someThing <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br></div><!--beforeend--></div><!--afterend--><p><strong>淘汰</strong>：</p>\n<p>IE9把BOM和DOM对象转为了真正的js对象，避免了使用这种垃圾收集策略，消除了IE9以下常见的内存泄漏的主要原因。</p>\n<p>IE7以下有一个声明狼藉的性能问题，大家了解一下：</p>\n<ol>\n<li>256个变量，4096个对象(或数组)字面或者64KB的字符串，达到任何一个临界值会触发垃圾收集器运行。</li>\n<li>如果一个js脚本的生命周期一直保有那么多变量，垃圾收集器会一直频繁的运行，引发严重的性能问题。</li>\n</ol>\n<p>IE7已修复这个问题。</p>\n<hr>\n<h2 id=\"哪些情况会引起内存泄漏？\"><a class=\"header-anchor\" href=\"#哪些情况会引起内存泄漏？\" aria-hidden=\"true\">#</a> 哪些情况会引起内存泄漏？</h2>\n<p>虽然有垃圾回收机制，但我们在编写代码的时候，有些情况还是会造成内存泄漏，了解这些情况，并在编写程序的时候，注意避免，我们的程序会更具健壮性。</p>\n<h3 id=\"意外的全局变量：\"><a class=\"header-anchor\" href=\"#意外的全局变量：\" aria-hidden=\"true\">#</a> 意外的全局变量：</h3>\n<p>上文我们提到了<strong>全局变量不会被当成垃圾回收</strong>，我们在编码中有时会出现下面这种情况：</p>\n<!--beforebegin--><div class=\"language-js line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>bar2 <span class=\"token operator\">=</span> <span class=\"token string\">'默认绑定this指向全局'</span> <span class=\"token comment\">// 全局变量=> window.bar2</span>\n    bar <span class=\"token operator\">=</span> <span class=\"token string\">'全局变量'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 没有声明变量 实际上是全局变量=>window.bar</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br></div><!--beforeend--></div><!--afterend--><p>当我们使用<a href=\"https://juejin.im/post/5b3715def265da59af40a630#heading-3\" target=\"_blank\" rel=\"noopener noreferrer\">默认绑定<OutboundLink/></a>，this会指向全局，<code>this.something</code>也会创建一个全局变量，这一点可能很多人没有注意到。</p>\n<p><strong>解决方法：在函数内使用严格模式or细心一点</strong></p>\n<!--beforebegin--><div class=\"language-js line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">\"use strict\"</span><span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>bar2 <span class=\"token operator\">=</span> <span class=\"token string\">\"严格模式下this指向undefined\"</span><span class=\"token punctuation\">;</span> \n    bar <span class=\"token operator\">=</span> <span class=\"token string\">\"报错\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br><span class=\"line-number\">6</span><br></div><!--beforeend--></div><!--afterend--><p>当然我们也可以<strong>手动释放全局变量的内存</strong>：</p>\n<!--beforebegin--><div class=\"language-js line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-js\"><code>window<span class=\"token punctuation\">.</span>bar <span class=\"token operator\">=</span> undefined\n<span class=\"token keyword\">delete</span> window<span class=\"token punctuation\">.</span>bar2\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br></div><!--beforeend--></div><!--afterend--><h3 id=\"被遗忘的定时器和回调函数\"><a class=\"header-anchor\" href=\"#被遗忘的定时器和回调函数\" aria-hidden=\"true\">#</a> 被遗忘的定时器和回调函数</h3>\n<p>当<strong>不需要</strong><code>setInterval</code>或者<code>setTimeout</code>时，<strong>定时器没有被clear</strong>，定时器的<strong>回调函数以及内部依赖的变量都不能被回收</strong>，造成内存泄漏。</p>\n<!--beforebegin--><div class=\"language-js line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">var</span> someResource <span class=\"token operator\">=</span> <span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> node <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Node'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        node<span class=\"token punctuation\">.</span>innerHTML <span class=\"token operator\">=</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>someResource<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 定时器也没有清除</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// node、someResource 存储了大量数据 无法回收</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br><span class=\"line-number\">6</span><br><span class=\"line-number\">7</span><br><span class=\"line-number\">8</span><br><span class=\"line-number\">9</span><br></div><!--beforeend--></div><!--afterend--><p><strong>解决方法</strong>： 在定时器完成工作的时候，手动清除定时器。</p>\n<h3 id=\"闭包：\"><a class=\"header-anchor\" href=\"#闭包：\" aria-hidden=\"true\">#</a> 闭包：</h3>\n<p><strong>闭包可以维持函数内局部变量，使其得不到释放，造成内存泄漏</strong>。</p>\n<!--beforebegin--><div class=\"language-js line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">bindEvent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"XXX\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> <span class=\"token function-variable function\">unused</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span><span class=\"token string\">'闭包内引用obj obj不会被释放'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// obj = null;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br><span class=\"line-number\">6</span><br><span class=\"line-number\">7</span><br></div><!--beforeend--></div><!--afterend--><p><strong>解决方法</strong>：手动解除引用，<code>obj = null</code>。</p>\n<h3 id=\"循环引用问题\"><a class=\"header-anchor\" href=\"#循环引用问题\" aria-hidden=\"true\">#</a> 循环引用问题</h3>\n<p>就是IE9以下的循环引用问题，上文讲过了。</p>\n<h3 id=\"没有清理dom元素引用：\"><a class=\"header-anchor\" href=\"#没有清理dom元素引用：\" aria-hidden=\"true\">#</a> 没有清理DOM元素引用：</h3>\n<!--beforebegin--><div class=\"language-js line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">var</span> refA <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'refA'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ndocument<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">.</span><span class=\"token function\">removeChild</span><span class=\"token punctuation\">(</span>refA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// dom删除了</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>refA<span class=\"token punctuation\">,</span> <span class=\"token string\">\"refA\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 但是还存在引用 能console出整个div 没有被回收</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br></div><!--beforeend--></div><!--afterend--><p>不信的话，可以看下这个<a href=\"https://codepen.io/OBKoro1/pen/vroKbg\" target=\"_blank\" rel=\"noopener noreferrer\">dom<OutboundLink/></a>。</p>\n<p><strong>解决办法</strong>：<code>refA = null</code>;</p>\n<h3 id=\"console保存大量数据在内存中。\"><a class=\"header-anchor\" href=\"#console保存大量数据在内存中。\" aria-hidden=\"true\">#</a> console保存大量数据在内存中。</h3>\n<p>过多的console，比如定时器的console会导致浏览器卡死。</p>\n<p><strong>解决</strong>：合理利用console，线上项目尽量少的使用console，当然如果你要发招聘除外。</p>\n<hr>\n<h3 id=\"如何避免内存泄漏：\"><a class=\"header-anchor\" href=\"#如何避免内存泄漏：\" aria-hidden=\"true\">#</a> 如何避免内存泄漏：</h3>\n<p><strong>记住一个原则：不用的东西，及时归还，毕竟你是'借的'嘛</strong>。</p>\n<ol>\n<li>减少不必要的全局变量，使用严格模式避免意外创建全局变量。</li>\n<li>在你使用完数据后，及时解除引用(闭包中的变量，dom引用，定时器清除)。</li>\n<li>组织好你的逻辑，避免死循环等造成浏览器卡顿，崩溃的问题。</li>\n</ol>\n<h3 id=\"关于内存泄漏：\"><a class=\"header-anchor\" href=\"#关于内存泄漏：\" aria-hidden=\"true\">#</a> 关于内存泄漏：</h3>\n<ol>\n<li>即使是1byte的内存，也叫内存泄漏，并不一定是导致浏览器崩溃、卡顿才能叫做内存泄漏。</li>\n<li>一般是堆区内存泄漏，栈区不会泄漏。</li>\n</ol>\n<p>基本类型的值存在内存中，被保存在栈内存中，引用类型的值是对象，保存在堆内存中。所以<strong>对象、数组之类的，才会发生内存泄漏</strong>。</p>\n<ol start=\"3\">\n<li>使用chorme监控内存泄漏，可以看一下这篇<a href=\"https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/\" target=\"_blank\" rel=\"noopener noreferrer\">文章<OutboundLink/></a></li>\n</ol>\n<h2 id=\"小结\"><a class=\"header-anchor\" href=\"#小结\" aria-hidden=\"true\">#</a> 小结</h2>\n<p>了解了内存泄漏的原因以及出现的情况，那么我们在编码过程中只要多加注意，就不会发生非常严重的内存泄漏问题。</p>\n<h3 id=\"鼓励我一下：\"><a class=\"header-anchor\" href=\"#鼓励我一下：\" aria-hidden=\"true\">#</a> 鼓励我一下：</h3>\n<p>觉得还不错的话，给我的项目点个<a href=\"https://github.com/OBKoro1/Brush_algorithm\" target=\"_blank\" rel=\"noopener noreferrer\">star<OutboundLink/></a>吧</p>\n<p>游泳、健身了解一下：<a href=\"http://obkoro1.com/\" target=\"_blank\" rel=\"noopener noreferrer\">博客<OutboundLink/></a>、<a href=\"https://github.com/OBKoro1/Brush_algorithm\" target=\"_blank\" rel=\"noopener noreferrer\">前端算法<OutboundLink/></a>、<a href=\"https://user-gold-cdn.xitu.io/2018/5/1/1631b6f52f7e7015?w=344&amp;h=344&amp;f=jpeg&amp;s=8317\" target=\"_blank\" rel=\"noopener noreferrer\">公众号<OutboundLink/></a></p>\n</div>\n",null]}