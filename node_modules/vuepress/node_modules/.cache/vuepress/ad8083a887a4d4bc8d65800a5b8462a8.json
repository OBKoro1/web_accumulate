{"remainingRequest":"/Users/koro/work/web_my/web_accumulate/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/koro/work/web_my/web_accumulate/docs/.vuepress/components/comment/comment.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/koro/work/web_my/web_accumulate/docs/.vuepress/components/comment/comment.vue","mtime":1561355462075},{"path":"/Users/koro/work/web_my/web_accumulate/node_modules/cache-loader/dist/cjs.js","mtime":1557296864520},{"path":"/Users/koro/work/web_my/web_accumulate/node_modules/babel-loader/lib/index.js","mtime":1557296864421},{"path":"/Users/koro/work/web_my/web_accumulate/node_modules/cache-loader/dist/cjs.js","mtime":1557296864520},{"path":"/Users/koro/work/web_my/web_accumulate/node_modules/vue-loader/lib/index.js","mtime":1557296867190}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport { setTimeout } from \"timers\";\nimport fs from 'fs'\nconsole.log('node',fs)\n\nexport default {\n  name: \"comment\",\n  data() {\n    return {};\n  },\n  methods: {\n    issueTitle() {\n      console.log(\"this\", this, window);\n      const title = location.pathname;\n      const pathArr = title.split(\"/\");\n      let res;\n      // \"js 调用栈机制与ES6尾调用优化介绍\"\n      // \"OBKoro1前端积累\"\n      let articleTile = this.$page.title;\n      if (pathArr[3]) {\n        // 文章页面创建issue\n        if (pathArr[2] === \"algorithm\") {\n          // 算法\n          let obj = {\n            induction: \"入门级-算法\",\n            simple: \"简单级-算法\",\n            medium: \"中等级-算法\"\n          };\n          res = `${articleTile} | ${obj[pathArr[3]]}`;\n        } else {\n          // 文章\n          res = `${articleTile} | ${pathArr[3]}`;\n        }\n      } else if (pathArr[2]) {\n        // 第二层主目录是否创建issue\n        let agreeArr = [\"accumulate\", \"algorithm\"];\n        if (agreeArr.includes(pathArr[2])) {\n          let obj = {\n            accumulate: \"OBKoro1博客\",\n            algorithm: \"前端算法\"\n          };\n          res = obj[pathArr[2]];\n        }\n      }\n      console.log(\"pathArr\", pathArr, res);\n      return [res, articleTile];\n    },\n    issueLabels() {\n      return this.$page.headers.map(item => {\n        return item.title;\n      });\n    }\n  },\n  mounted() {\n    let body = document.querySelector(\".gitalk-container\");\n    let script = document.createElement(\"script\");\n    script.src = \"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js\";\n    body.appendChild(script);\n    script.onload = () => {\n      const [title, articleTile] = this.issueTitle();\n\n      // 创建issue TODO: false\n      if (false) {\n        const commentConfig = {\n          clientID: \"8fbce2735aa4b865e9df\",\n          clientSecret: \"c2d2947de913af238dc5a22b1db8de0d9e834096\",\n          repo: \"web_accumulate\",\n          owner: \"OBKoro1\",\n          // 这里接受一个数组，可以添加多个管理员\n          admin: [\"OBKoro1\"],\n          // id 用于当前页面的唯一标识，一般来讲 pathname 足够了，\n\n          // 但是如果你的 pathname 超过 50 个字符，GitHub 将不会成功创建 issue，此情况可以考虑给每个页面生成 hash 值的方法.\n          id: articleTile, // issue title\n          title,\n          // body:,\n          labels: this.issueLabels(),\n          distractionFreeMode: false,\n          // 如果当前页面没有相应的 isssue 且登录的用户属于 admin，则会自动创建 issue。如果设置为 true，则显示一个初始化页面，创建 issue 需要点击 init 按钮\n          createIssueManually: true\n        };\n        const gitalk = new Gitalk(commentConfig);\n        gitalk.render(\"gitalk-container\");\n        console.log(\n          'document.querySelector(\".gt-copyright\")',\n          commentConfig,\n        );\n      }\n    };\n  }\n};\n",null]}