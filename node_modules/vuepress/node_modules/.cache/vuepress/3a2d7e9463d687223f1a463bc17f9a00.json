{"remainingRequest":"/Users/koro/work/web_my/web_accumulate/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/koro/work/web_my/web_accumulate/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/koro/work/web_my/web_accumulate/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/koro/work/web_my/web_accumulate/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/koro/work/web_my/web_accumulate/docs/accumulate/tool/js垃圾回收机制.md?vue&type=template&id=693d4132&","dependencies":[{"path":"/Users/koro/work/web_my/web_accumulate/docs/accumulate/tool/js垃圾回收机制.md","mtime":1636107879474},{"path":"/Users/koro/work/web_my/web_accumulate/node_modules/cache-loader/dist/cjs.js","mtime":1557296864520},{"path":"/Users/koro/work/web_my/web_accumulate/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1557296867191},{"path":"/Users/koro/work/web_my/web_accumulate/node_modules/cache-loader/dist/cjs.js","mtime":1557296864520},{"path":"/Users/koro/work/web_my/web_accumulate/node_modules/vue-loader/lib/index.js","mtime":1557296867190},{"path":"/Users/koro/work/web_my/web_accumulate/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1557296867284}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<h2 id=\\\"js高程中的垃圾回收机制与常见内存泄露的解决方法\\\"><a href=\\\"#js高程中的垃圾回收机制与常见内存泄露的解决方法\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> JS高程中的垃圾回收机制与常见内存泄露的解决方法</h2> <p>起因是因为想了解闭包的内存泄露机制，然后想起《js高级程序设计》中有关于垃圾回收机制的解析，之前没有很懂，过一年回头再看就懂了，写篇博客与大家分享一下。</p> <h3 id=\\\"内存的生命周期：\\\"><a href=\\\"#内存的生命周期：\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 内存的生命周期：</h3> <ol><li>分配你所需要的内存：</li></ol> <p>由于字符串、对象等没有固定的大小，js程序在每次创建字符串、对象的时候，程序都会<strong>分配内存来存储那个实体</strong>。</p> <ol start=\\\"2\\\"><li><p>使用分配到的内存做点什么。</p></li> <li><p>不需要时将其释放回归：</p></li></ol> <p>在不需要字符串、对象的时候，需要释放其所占用的内存，否则将会消耗完系统中所有可用的内存，造成系统崩溃，这就是<strong>垃圾回收机制所存在的意义</strong>。</p> <p><strong>所谓的内存泄漏指的是</strong>：由于疏忽或错误造成程序未能释放那些已经不再使用的内存，造成内存的浪费。</p> <hr> <h2 id=\\\"垃圾回收机制：\\\"><a href=\\\"#垃圾回收机制：\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 垃圾回收机制：</h2> <p>在C和C++之类的语言中，需要手动来管理内存的，这也是造成许多不必要问题的根源。幸运的是，在编写js的过程中，内存的分配以及内存的回收完全实现了自动管理，我们不用操心这种事情。</p> <h3 id=\\\"垃圾收集机制的原理：\\\"><a href=\\\"#垃圾收集机制的原理：\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 垃圾收集机制的原理：</h3> <p>垃圾收集器会按照固定的时间间隔，<strong>周期性的找出不再继续使用的变量，然后释放其占用的内存</strong>。</p> <p><strong>什么叫不再继续使用的变量？</strong></p> <p>不再使用的变量也就是生命周期结束的变量，是局部变量，局部变量只在函数的执行过程中存在，当函数运行结束，没有其他引用(闭包)，那么该变量会被标记回收。</p> <p>全局变量的生命周期直至浏览器卸载页面才会结束，也就是说<strong>全局变量不会被当成垃圾回收</strong>。</p> <h3 id=\\\"标记清除：当前采用的垃圾收集策略\\\"><a href=\\\"#标记清除：当前采用的垃圾收集策略\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 标记清除：当前采用的垃圾收集策略</h3> <p>工作原理：</p> <p>当变量进入环境时(例如在函数中声明一个变量)，将这个变量标记为“进入环境”，当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。</p> <p>工作流程：</p> <ol><li>垃圾收集器会在运行的时候会给存储在内存中的<strong>所有变量都加上标记</strong>。</li> <li><strong>去掉环境中的变量</strong>以及被环境中的变量引用的变量的标记。</li> <li>那些<strong>还存在标记的变量被视为准备删除的变量</strong>。</li> <li>最后垃圾收集器会执行最后一步内存清除的工作，<strong>销毁那些带标记的值并回收它们所占用的内存空间</strong>。</li></ol> <p>到2008年为止,IE、Chorme、Fireofx、Safari、Opera <strong>都使用标记清除式的垃圾收集策略</strong>，只不过垃圾收集的时间间隔互有不同。</p> <h3 id=\\\"引用计数略：被废弃的垃圾收集策略\\\"><a href=\\\"#引用计数略：被废弃的垃圾收集策略\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 引用计数略：被废弃的垃圾收集策略</h3> <p>循环引用：跟踪记录每个值被引用的技术</p> <p>在老版本的浏览器中(对，又是IE)，IE9以下BOM和DOM对象就是使用C++以COM对象的形式实现的。</p> <p>COM的垃圾收集机制采用的就是引用计数策略，这种机制在出现循环引用的时候永远都释放不掉内存。</p> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">let</span> element <span class=\\\"token operator\\\">=</span> document<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getElementById</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'something'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">let</span> myObject <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Object</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nmyObject<span class=\\\"token punctuation\\\">.</span>element <span class=\\\"token operator\\\">=</span> element<span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// element属性指向dom</span>\\nelement<span class=\\\"token punctuation\\\">.</span>someThing <span class=\\\"token operator\\\">=</span> myObject<span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// someThing回指myObject 出现循环引用(两个对象一直互相包含 一直存在计数)。</span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br></div></div><p>解决方式是，当我们不使用它们的时候，手动切断链接：</p> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code>myObject<span class=\\\"token punctuation\\\">.</span>element <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">null</span><span class=\\\"token punctuation\\\">;</span> \\nelement<span class=\\\"token punctuation\\\">.</span>someThing <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">null</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div><p><strong>淘汰</strong>：</p> <p>IE9把BOM和DOM对象转为了真正的js对象，避免了使用这种垃圾收集策略，消除了IE9以下常见的内存泄漏的主要原因。</p> <p>IE7以下有一个声明狼藉的性能问题，大家了解一下：</p> <ol><li>256个变量，4096个对象(或数组)字面或者64KB的字符串，达到任何一个临界值会触发垃圾收集器运行。</li> <li>如果一个js脚本的生命周期一直保有那么多变量，垃圾收集器会一直频繁的运行，引发严重的性能问题。</li></ol> <p>IE7已修复这个问题。</p> <hr> <h2 id=\\\"哪些情况会引起内存泄漏？\\\"><a href=\\\"#哪些情况会引起内存泄漏？\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 哪些情况会引起内存泄漏？</h2> <p>虽然有垃圾回收机制，但我们在编写代码的时候，有些情况还是会造成内存泄漏，了解这些情况，并在编写程序的时候，注意避免，我们的程序会更具健壮性。</p> <h3 id=\\\"意外的全局变量：\\\"><a href=\\\"#意外的全局变量：\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 意外的全局变量：</h3> <p>上文我们提到了<strong>全局变量不会被当成垃圾回收</strong>，我们在编码中有时会出现下面这种情况：</p> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">foo</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>bar2 <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'默认绑定this指向全局'</span> <span class=\\\"token comment\\\">// 全局变量=&gt; window.bar2</span>\\n    bar <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'全局变量'</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// 没有声明变量 实际上是全局变量=&gt;window.bar</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token function\\\">foo</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br></div></div>\"),_vm._ssrNode(\"<p>\",\"</p>\",[_vm._ssrNode(\"当我们使用\"),_vm._ssrNode(\"<a href=\\\"https://juejin.im/post/5b3715def265da59af40a630#heading-3\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"默认绑定\"),_c('OutboundLink')],2),_vm._ssrNode(\"，this会指向全局，<code>this.something</code>也会创建一个全局变量，这一点可能很多人没有注意到。\")],2),_vm._ssrNode(\" <p><strong>解决方法：在函数内使用严格模式or细心一点</strong></p> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">foo</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token string\\\">&quot;use strict&quot;</span><span class=\\\"token punctuation\\\">;</span> \\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>bar2 <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">&quot;严格模式下this指向undefined&quot;</span><span class=\\\"token punctuation\\\">;</span> \\n    bar <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">&quot;报错&quot;</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token function\\\">foo</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br></div></div><p>当然我们也可以<strong>手动释放全局变量的内存</strong>：</p> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code>window<span class=\\\"token punctuation\\\">.</span>bar <span class=\\\"token operator\\\">=</span> undefined\\n<span class=\\\"token keyword\\\">delete</span> window<span class=\\\"token punctuation\\\">.</span>bar2\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div><h3 id=\\\"被遗忘的定时器和回调函数\\\"><a href=\\\"#被遗忘的定时器和回调函数\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 被遗忘的定时器和回调函数</h3> <p>当<strong>不需要</strong><code>setInterval</code>或者<code>setTimeout</code>时，<strong>定时器没有被clear</strong>，定时器的<strong>回调函数以及内部依赖的变量都不能被回收</strong>，造成内存泄漏。</p> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> someResource <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">getData</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token function\\\">setInterval</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">var</span> node <span class=\\\"token operator\\\">=</span> document<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getElementById</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'Node'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">if</span><span class=\\\"token punctuation\\\">(</span>node<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        node<span class=\\\"token punctuation\\\">.</span>innerHTML <span class=\\\"token operator\\\">=</span> <span class=\\\"token constant\\\">JSON</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">stringify</span><span class=\\\"token punctuation\\\">(</span>someResource<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token comment\\\">// 定时器也没有清除</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token comment\\\">// node、someResource 存储了大量数据 无法回收</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token number\\\">1000</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br><span class=\\\"line-number\\\">9</span><br></div></div><p><strong>解决方法</strong>： 在定时器完成工作的时候，手动清除定时器。</p> <h3 id=\\\"闭包：\\\"><a href=\\\"#闭包：\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 闭包：</h3> <p><strong>闭包可以维持函数内局部变量，使其得不到释放，造成内存泄漏</strong>。</p> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">bindEvent</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">var</span> obj <span class=\\\"token operator\\\">=</span> document<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">createElement</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">&quot;XXX&quot;</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">var</span> <span class=\\\"token function-variable function\\\">unused</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>obj<span class=\\\"token punctuation\\\">,</span><span class=\\\"token string\\\">'闭包内引用obj obj不会被释放'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token comment\\\">// obj = null;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br></div></div><p><strong>解决方法</strong>：手动解除引用，<code>obj = null</code>。</p> <h3 id=\\\"循环引用问题\\\"><a href=\\\"#循环引用问题\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 循环引用问题</h3> <p>就是IE9以下的循环引用问题，上文讲过了。</p> <h3 id=\\\"没有清理dom元素引用：\\\"><a href=\\\"#没有清理dom元素引用：\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 没有清理DOM元素引用：</h3> <div class=\\\"language-js line-numbers-mode\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> refA <span class=\\\"token operator\\\">=</span> document<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getElementById</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'refA'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\ndocument<span class=\\\"token punctuation\\\">.</span>body<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">removeChild</span><span class=\\\"token punctuation\\\">(</span>refA<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// dom删除了</span>\\nconsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>refA<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token string\\\">&quot;refA&quot;</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>  <span class=\\\"token comment\\\">// 但是还存在引用 能console出整个div 没有被回收</span>\\n</code></pre> <div class=\\\"line-numbers-wrapper\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div>\"),_vm._ssrNode(\"<p>\",\"</p>\",[_vm._ssrNode(\"不信的话，可以看下这个\"),_vm._ssrNode(\"<a href=\\\"https://codepen.io/OBKoro1/pen/vroKbg\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"dom\"),_c('OutboundLink')],2),_vm._ssrNode(\"。\")],2),_vm._ssrNode(\" <p><strong>解决办法</strong>：<code>refA = null</code>;</p> <h3 id=\\\"console保存大量数据在内存中。\\\"><a href=\\\"#console保存大量数据在内存中。\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> console保存大量数据在内存中。</h3> <p>过多的console，比如定时器的console会导致浏览器卡死。</p> <p><strong>解决</strong>：合理利用console，线上项目尽量少的使用console，当然如果你要发招聘除外。</p> <hr> <h3 id=\\\"如何避免内存泄漏：\\\"><a href=\\\"#如何避免内存泄漏：\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 如何避免内存泄漏：</h3> <p><strong>记住一个原则：不用的东西，及时归还，毕竟你是'借的'嘛</strong>。</p> <ol><li>减少不必要的全局变量，使用严格模式避免意外创建全局变量。</li> <li>在你使用完数据后，及时解除引用(闭包中的变量，dom引用，定时器清除)。</li> <li>组织好你的逻辑，避免死循环等造成浏览器卡顿，崩溃的问题。</li></ol> <h3 id=\\\"关于内存泄漏：\\\"><a href=\\\"#关于内存泄漏：\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 关于内存泄漏：</h3> <ol><li>即使是1byte的内存，也叫内存泄漏，并不一定是导致浏览器崩溃、卡顿才能叫做内存泄漏。</li> <li>一般是堆区内存泄漏，栈区不会泄漏。</li></ol> <p>基本类型的值存在内存中，被保存在栈内存中，引用类型的值是对象，保存在堆内存中。所以<strong>对象、数组之类的，才会发生内存泄漏</strong>。</p> \"),_vm._ssrNode(\"<ol start=\\\"3\\\">\",\"</ol>\",[_vm._ssrNode(\"<li>\",\"</li>\",[_vm._ssrNode(\"使用chorme监控内存泄漏，可以看一下这篇\"),_vm._ssrNode(\"<a href=\\\"https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"文章\"),_c('OutboundLink')],2)],2)]),_vm._ssrNode(\" <h2 id=\\\"小结\\\"><a href=\\\"#小结\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 小结</h2> <p>了解了内存泄漏的原因以及出现的情况，那么我们在编码过程中只要多加注意，就不会发生非常严重的内存泄漏问题。\\n</p> \"),_vm._ssrNode(\"<h3 id=\\\"点个star支持我一下\\\">\",\"</h3>\",[_vm._ssrNode(\"<a href=\\\"#点个star支持我一下\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 点个\"),_vm._ssrNode(\"<a href=\\\"https://github.com/OBKoro1/web_accumulate\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"Star\"),_c('OutboundLink')],2),_vm._ssrNode(\"支持我一下~\")],2),_vm._ssrNode(\" \"),_c('comment-comment')],2)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}