## 102 二叉树的层序遍历

### [题目链接](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

### 难度：中等

### 思路分析：

深度优先和广度优先

### 想

### 一

### 想

### 再

### 看

### 答

### 案

### 想

### 一

### 想

### 再

### 看

### 答

### 案

### 代码：

**深度优先**:

```js
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
// dfs深度优先
var levelOrder = function(root) {
  const res = [];
  const levelNum = 0; // 当前层级
  dfs(root, levelNum);
  function dfs(node, step) {
    if (node) {
      // 当前节点是否有值
      if (res[step]) {
        // 该层级已添加过节点 在当前层级中继续添加
        res[step].push(node.val);
      } else {
        // 当前层级未添加过节点 创建一个数组 添加节点
        res.push([node.val]);
      }
      // 循环下个节点 增加层级
      dfs(node.left, step + 1);
      dfs(node.right, step + 1);
    }
  }
  return res;
};
```

**广度优先**:

```js
var levelOrder = function(root) {
  const ret = [];
  if (!root) return ret;
  const q = []; // 栈
  q.push(root);
  while (q.length !== 0) {
    const currentLevelSize = q.length; // 记录下一层级的数量
    ret.push([]); // 层级初始化
    // 遍历广度 同一层级的元素都取出来
    for (let i = 1; i <= currentLevelSize; ++i) {
      const node = q.shift(); // 取出同一层级的元素
      ret[ret.length - 1].push(node.val); // 添加广度同一节点
      // 下个层级
      if (node.left) q.push(node.left);
      if (node.right) q.push(node.right);
    }
  }
  return ret;
};
```

### 鼓励我一下：

觉得还不错的话，给我的项目点个[star](https://github.com/OBKoro1/Brush_algorithm)吧
<!-- 特殊字符串：用于修改/删除markdown的结尾提示语-OBKoro1 -->
### 点个[Star](https://github.com/OBKoro1/Brush_algorithm)支持我一下~

