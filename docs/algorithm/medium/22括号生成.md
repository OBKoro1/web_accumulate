## 22 括号生成

### [题目链接](https://leetcode-cn.com/problems/generate-parentheses/)

### 难度：中等

### 思路分析：

树思想 回溯

### 想

### 一

### 想

### 再

### 看

### 答

### 案

### 想

### 一

### 想

### 再

### 看

### 答

### 案

### 代码：

树思想 回溯 深度优先遍历

```js
var generateParenthesis2 = function(n) {
  let left = (right = n); // 左右分支的数量
  let res = [];
  if (n == 0) {
    return res;
  }
  dfs("", left, right);
  function dfs(preStr, left, right) {
    // 当没有括号时 即回溯终止
    if (left === 0 && right === 0) {
      res.push(preStr);
      return;
    }
    // 当成一颗深度为2n的树来做 每个括号在这棵树内都会都用到
    // 剪枝: 左括号可以使用的个数严格大于右括号可以使用的个数时 左侧也会生出分支准备生出右侧的括号
    if (left > right) {
      return;
    }
    // 一次添加左侧一次添加右侧 回溯 凑成括号
    if (left > 0) {
      dfs(`${preStr}(`, left - 1, right);
    }
    if (right > 0) {
      dfs(`${preStr})`, left, right - 1);
    }
  }
  return res;
};
```

回溯加法方式 深度优先遍历

```js
var generateParenthesis3 = function(n) {
  let res = [];
  dfs("", 0, 0);
  function dfs(preStr, left, right) {
    // 括号数量用完了 取消回溯
    if (left === n && right === n) {
      res.push(preStr);
      return;
    }
    // 当左边的数量小于右边时 左侧也会生出分支准备生出右侧的括号
    if (left < right) {
      return;
    }
    // 一次添加左侧一次添加右侧 回溯 凑成括号
    if (left < n) {
      dfs(`${preStr}(`, left + 1, right);
    }
    if (right < n) {
      dfs(`${preStr})`, left, right + 1);
    }
  }
  return res;
};
```

### 鼓励我一下：

觉得还不错的话，给我的项目点个[star](https://github.com/OBKoro1/Brush_algorithm)吧
<!-- 特殊字符串：用于修改/删除markdown的结尾提示语-OBKoro1 -->
### 点个[Star](https://github.com/OBKoro1/Brush_algorithm)支持我一下~

